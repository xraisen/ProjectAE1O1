<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Planet Beauty AI Chatbot - Find personalized beauty products with our interactive assistant.">
    <link rel="icon" href="https://via.placeholder.com/16x16/E91e63/FFFFFF?text=PB" type="image/png">
    <title>Planet Beauty AI Chatbot</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX'); // Replace with your GA ID
    </script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f8f9fa;
            margin: 0;
            overflow-x: hidden;
        }
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f9fa;
            display: flex;
            flex-direction: column; /* NEW: Stack spinner and percentage */
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #e91e63;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem; /* NEW: Space between spinner and percentage */
        }
        /* NEW: Style for percentage display */
        #preloader .percentage {
            font-size: 1.5rem;
            font-weight: 500;
            color: #e91e63;
        }
        .chat-container {
            max-width: 900px;
            margin: 0 auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 12px;
            background: white;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 140px);
            max-height: 800px;
        }
        .chat-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
            will-change: scroll-position;
        }
        .user-message {
            background: #e91e63;
            color: white;
            padding: .75rem 1rem;
            border-radius: 15px 15px 0 15px;
            max-width: 80%;
            margin-left: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .bot-message {
            background: #f0f0f0;
            color: #333;
            padding: .75rem 1rem;
            border-radius: 15px 15px 15px 0;
            max-width: 80%;
            margin-right: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .product-card {
            display: block;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            margin: 1rem 0;
            text-decoration: none;
            color: inherit;
            background: white;
            max-width: 80%;
            margin-right: auto;
        }
        .product-card:hover {
            transform: scale(1.03);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .product-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }
        .lazyload, .lazyloading {
            opacity: 0;
            transition: opacity 0.3s;
        }
        .lazyloaded {
            opacity: 1;
        }
        .image-loading {
            position: relative;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f5f5f5;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(233, 30, 99, 0.2);
            border-top-color: #e91e63;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .image-placeholder {
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #eee;
            color: #666;
            font-size: 0.9em;
            text-align: center;
        }
        .product-info {
            padding: 1rem;
        }
        .product-name {
            font-weight: 600;
            margin-bottom: .25rem;
        }
        .product-description {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: .5rem;
        }
        .product-price {
            font-weight: 500;
            color: #e91e63;
        }
        .examples-container {
            display: flex;
            flex-wrap: wrap;
            gap: .5rem;
            margin-bottom: 1rem;
            max-width: 80%;
        }
        .example-chip {
            padding: .5rem 1rem;
            background: #f0f0f0;
            border: 1px solid #e0e0e0;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s, box-shadow 0.2s;
            font-size: 0.9rem;
        }
        .example-chip:hover {
            background: #e91e63;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .example-chip:focus {
            outline: 2px solid #e91e63;
            outline-offset: 2px;
        }
        .input-area {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #eee;
            background: #fff;
        }
        .input-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        input[type=text] {
            flex: 1;
            padding: .75rem 1rem;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            transition: border-color 0.3s;
        }
        input[type=text]:focus {
            border-color: #e91e63;
        }
        input[type=text]:disabled {
            background-color: #f5f5f5;
        }
        .send-btn {
            background: #e91e63;
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            flex-shrink: 0;
        }
        .send-btn:hover {
            background: #d81b60;
            transform: scale(1.05);
        }
        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: .75rem 1rem;
            border-radius: 15px;
            margin-bottom: 1rem;
            max-width: 80%;
            margin-right: auto;
            border: 1px solid #f4c7c7;
        }
        .retry-btn {
            background: none;
            border: none;
            color: #e91e63;
            text-decoration: underline;
            cursor: pointer;
        }
        footer {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 0.5rem 1rem;
            color: #6c757d;
            font-size: 0.875rem;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        footer a {
            color: #e91e63;
            text-decoration: none;
            margin-left: 0.25rem;
        }
        footer a:hover {
            text-decoration: underline;
        }
        #typing-indicator .typing-dots {
            display: inline-block;
            width: 1.5em;
            text-align: left;
            vertical-align: bottom;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @media (max-width: 640px) {
            body {
                padding: 0;
            }
            .chat-container {
                border-radius: 0;
                max-width: 100%;
                height: 100vh;
                max-height: none;
                margin: 0;
            }
            .chat-area {
                padding: 1rem;
            }
            .user-message, .bot-message, .product-card, .examples-container, .error-message {
                max-width: 90%;
            }
            .input-area {
                padding: 0.75rem;
            }
            input[type=text] {
                padding: 0.6rem 0.9rem;
            }
            .send-btn {
                width: 40px;
                height: 40px;
            }
            footer {
                font-size: 0.8rem;
                padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
            }
            /* NEW: Adjust preloader for mobile */
            #preloader .percentage {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <!-- MODIFIED: Added percentage display to preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <div class="percentage">0%</div>
    </div>
    <header class="text-center py-6 px-4 flex-shrink-0 bg-gradient-to-r from-pink-600 to-purple-700 text-white shadow-md animate-fade-in">
        <h1 class="text-3xl sm:text-4xl font-bold">Planet Beauty</h1>
        <p class="text-lg sm:text-xl">Your AI Beauty Assistant ‚ú®</p>
    </header>

    <main class="chat-container flex-grow animate-fade-in">
        <div id="chat-area" class="chat-area">
            <div class="bot-message">Hi there! Welcome to Planet Beauty's AI Assistant. ‚ú® How can I help you find the perfect products today?</div>
            <div id="examples-container" class="examples-container"></div>
        </div>

        <div class="input-area">
            <div class="input-row">
                <input id="chat-input" type="text" placeholder="Ask about beauty products..." autocomplete="off" aria-label="Type your beauty product question">
                <button id="send-btn" class="send-btn" disabled aria-label="Send message"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </main>

    <footer>
        <span>Developed with ‚ù§Ô∏è by</span>
        <a href="https://www.linkedin.com/in/joseespinosa" target="_blank" rel="noopener noreferrer">Jose Espinosa</a>
    </footer>

    <script>
        // --- Configuration ---
        const GEMINI_API_KEY = 'AIzaSyCpI-eNfqWk_ZiK2qHOj_tD2NzeAJ_U398'; // Replace with your Gemini API key
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`; // Updated model
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzzp5mD6Nu3RZmYvjzDFXvCNC5MhJyfNMvs_MJDYLqZ8Uad1BJE-cO1WWg7BpoYO62_/exec'; // Replace with your deployed Web App URL
        const API_TIMEOUT = 20000; // Increased timeout slightly
        const IMAGE_TIMEOUT = 15000;
        const PLANET_BEAUTY_URL = 'https://www.planetbeauty.com/'; // Client's base URL

        // NEW: Preloader configuration
        const PRELOADER_MIN_DURATION = 1000; // Minimum duration for preloader (ms)
        const PERCENTAGE_ANIMATION_DURATION = 2000; // Duration for percentage animation (ms)

        // --- Fallback Questions ---
        const FALLBACK_QUESTIONS = [
            "What products are best for sensitive skin?",
            "Can you recommend a conditioner for curly hair?",
            "What's a good cleanser for combination skin?",
            "Which makeup is ideal for a natural look?"
        ];

        // --- State ---
        const userProfile = { skinType: null, skinTone: null, concerns: [] };
        let conversationHistory = [];
        const MAX_HISTORY = 6; // Max user/model pairs
        const imageCache = JSON.parse(localStorage.getItem('imageCache')) || {};
        let products = [];
        let productCategories = {};
        const backupImages = {
            default: 'https://via.placeholder.com/600x400/E91e63/FFFFFF?text=Planet+Beauty',
        };

        // --- Category Keywords ---
        // NOTE: Consider adding 'device', 'tool', 'led', 'light therapy' if relevant products exist
        const categoryKeywords = {
            acne: ['acne', 'blemish', 'pimple', 'breakout', 'clear skin', 'oily'],
            moisturizer: ['moisturizer', 'hydrating', 'dry skin', 'hydration', 'cream', 'lotion'],
            shampoo: ['shampoo', 'hair wash', 'clean hair'],
            conditioner: ['conditioner', 'soften hair', 'detangle'],
            hairmask: ['hair mask', 'treatment', 'damaged hair', 'repair hair'],
            foundation: ['foundation', 'makeup base', 'cover', 'complexion', 'tone', 'bb cream', 'cc cream'],
            serum: ['serum', 'treatment', 'concentrate', 'essence'],
            cleanser: ['cleanser', 'face wash', 'wash', 'makeup remover'],
            exfoliant: ['exfoliant', 'scrub', 'peel', 'smooth skin', 'aha', 'bha'],
            styling: ['styling', 'hairspray', 'texture', 'volume', 'hold', 'gel', 'mousse', 'pomade'],
            skincare: ['skincare', 'face care', 'complexion', 'skin health'],
            haircare: ['haircare', 'hair product', 'mane'],
            sunscreen: ['sunscreen', 'spf', 'uv', 'protection', 'sun block'],
            // Example of adding a new category if data exists:
            // devices: ['device', 'tool', 'led', 'red light', 'mask', 'therapy', 'facial tool']
        };

        // --- DOM Elements ---
        const chatArea = document.getElementById('chat-area');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const preloader = document.getElementById('preloader');
        const examplesContainer = document.getElementById('examples-container');

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            // NEW: Start percentage animation
            let percentage = 0;
            const percentageElement = preloader.querySelector('.percentage');
            const animatePercentage = () => {
                return new Promise(resolve => {
                    anime({
                        targets: { value: percentage },
                        value: 90, // Animate to 90% to leave room for completion
                        duration: PERCENTAGE_ANIMATION_DURATION,
                        easing: 'easeOutQuad',
                        update: (anim) => {
                            percentage = Math.round(anim.animatables[0].target.value);
                            percentageElement.textContent = `${percentage}%`;
                        },
                        complete: () => resolve()
                    });
                });
            };

            // MODIFIED: Keep preloader until fetch is complete
            const minDurationPromise = new Promise(resolve => setTimeout(resolve, PRELOADER_MIN_DURATION));
            const animationPromise = animatePercentage();
            try {
                products = await fetchProducts(percentageElement);
                categorizeProducts();
                await generateSuggestedQuestions();
                // Wait for both minimum duration and animations
                await Promise.all([minDurationPromise, animationPromise]);
                // Complete the percentage to 100%
                await anime({
                    targets: { value: percentage },
                    value: 100,
                    duration: 300,
                    easing: 'easeOutQuad',
                    update: (anim) => {
                        percentageElement.textContent = `${Math.round(anim.animatables[0].target.value)}%`;
                    }
                }).finished;
                // Fade out preloader
                preloader.style.opacity = '0';
                setTimeout(() => preloader.remove(), 500);
            } catch (error) {
                console.error('Initialization error:', error);
                // Update percentage to show error state
                percentageElement.textContent = 'Error';
                percentageElement.style.color = '#c62828';
                await Promise.all([minDurationPromise, animationPromise]);
                // Fade out preloader even on error
                preloader.style.opacity = '0';
                setTimeout(() => preloader.remove(), 500);
                // Display error in chat if product loading failed
                addMessage("Sorry, I couldn't load the product catalog right now. My recommendations might be limited. Please try refreshing the page later.", 'bot');
            }

            anime({
                targets: 'header',
                translateY: [-20, 0],
                opacity: [0, 1],
                duration: 800,
                easing: 'easeOutQuad'
            });

            chatInput.addEventListener('keyup', handleInputKeyup);
            chatInput.addEventListener('input', handleInputChange);
            sendBtn.addEventListener('click', () => {
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            });
            chatInput.focus();
            updateSendButtonState();
        });

        // --- Fetch Products from Google Apps Script Web App ---
        // MODIFIED: Added percentageElement parameter to update UI
        async function fetchProducts(percentageElement) {
            try {
                const res = await axios.get(WEB_APP_URL, { timeout: API_TIMEOUT });
                if (res.data && res.data.products && Array.isArray(res.data.products)) {
                    products = res.data.products.map((p, index) => ({
                        ...p,
                        id: p.id || `p${index + 1}`, // Ensure unique ID
                        name: typeof p.name === 'string' ? p.name.trim() : `Product ${index + 1}`, // Sanitize name
                        description: typeof p.description === 'string' ? p.description.trim() : '', // Sanitize description
                        price: typeof p.price === 'string' || typeof p.price === 'number' ? String(p.price).trim() : '', // Sanitize price
                        image: p.image && typeof p.image === 'string' && p.image.startsWith('http://') ? p.image.replace('http://', 'https://') : (p.image || ''), // Ensure HTTPS and handle missing
                        url: p.url || null // Use provided URL if available
                    }));
                    console.log("Products loaded from Web App:", products.length);
                    return products;
                } else if (res.data && res.data.error) {
                    throw new Error(`Web App Error: ${res.data.error}`);
                } else {
                    throw new Error("Invalid data format received from Web App.");
                }
            } catch (error) {
                console.error('Failed to fetch products:', error);
                // Error message handled in initialization now
                throw error; // Re-throw to handle in initialization
            }
        }

        // --- Categorize Products ---
        function categorizeProducts() {
            if (!products || products.length === 0) return;
            products.forEach(product => {
                product.categories = [];
                const nameLower = (product.name || "").toLowerCase();
                const descLower = (product.description || "").toLowerCase();
                for (const [category, keywords] of Object.entries(categoryKeywords)) {
                    if (keywords.some(keyword => nameLower.includes(keyword) || descLower.includes(keyword))) {
                        product.categories.push(category);
                    }
                }
            });
            // Create map of category -> products
            productCategories = Object.fromEntries(
                Object.keys(categoryKeywords).map(category => [
                    category,
                    products.filter(p => p.categories && p.categories.includes(category))
                ])
            );
            // Populate backup images per category
            for (const category of Object.keys(productCategories)) {
                backupImages[category] = productCategories[category]
                    .map(p => p.image)
                    .filter(img => img && typeof img === 'string'); // Ensure valid image URLs
            }
            console.log("Products categorized.");
        }

        // --- Suggested Questions ---
        async function generateSuggestedQuestions() {
            try {
                const questions = await fetchSuggestedQuestions();
                displaySuggestedQuestions(questions);
            } catch (error) {
                console.error('Failed to generate suggested questions:', error);
                displaySuggestedQuestions(FALLBACK_QUESTIONS); // Use hardcoded fallbacks
            }
        }

        async function fetchSuggestedQuestions() {
            const prompt = {
                contents: [{
                    role: 'user',
                    parts: [{
                        text: `Generate 4 concise, varied, and helpful beauty-related questions for the Planet Beauty chatbot. Questions should cover common user needs like specific product recommendations (e.g., for skin type, hair concern, makeup style) or general advice. Return the response strictly as a JSON array of 4 strings. Example:
                        ["What's the best moisturizer for oily skin?", "Can you recommend a shampoo for dry, damaged hair?", "What foundation gives a natural, dewy finish?", "Which serum helps reduce the appearance of fine lines?"]`
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topP: 0.95,
                    topK: 40,
                    maxOutputTokens: 256,
                    responseMimeType: 'application/json'
                },
                safetySettings: [ // Standard safety settings
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                ]
            };

            try {
                const res = await axios.post(GEMINI_API_URL, prompt, {
                    headers: { 'Content-Type': 'application/json' },
                    timeout: API_TIMEOUT
                });

                if (res.data && res.data.candidates && res.data.candidates[0] &&
                    res.data.candidates[0].content && res.data.candidates[0].content.parts &&
                    res.data.candidates[0].content.parts[0] && res.data.candidates[0].content.parts[0].text) {
                    const responseText = res.data.candidates[0].content.parts[0].text;
                    try {
                        // Attempt to clean and parse the JSON
                        const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                        const questions = JSON.parse(cleanedText);
                        // Validate the structure
                        if (Array.isArray(questions) && questions.length >= 4 && questions.every(q => typeof q === 'string')) {
                            return questions.slice(0, 4); // Return the first 4 valid questions
                        } else {
                            console.error('Parsed questions are not in the expected format:', questions);
                        }
                    } catch (parseError) {
                        console.error('JSON Parse Error for questions:', parseError, 'Raw text:', responseText);
                    }
                }
            } catch (apiError) {
                 console.error('Error fetching suggested questions from API:', apiError);
                 // Don't re-throw here, allow fallback in calling function
            }
            // If API call fails or parsing fails, throw to trigger fallback
            throw new Error('Failed to fetch valid questions from API.');
        }

        function displaySuggestedQuestions(questions) {
            examplesContainer.innerHTML = ''; // Clear previous suggestions
            if (!Array.isArray(questions)) {
                console.error("Cannot display suggestions: input is not an array.", questions);
                questions = FALLBACK_QUESTIONS; // Default to fallback if input is invalid
            }
            questions.forEach((question, index) => {
                if (typeof question !== 'string' || !question.trim()) { // Check for valid string
                    console.warn(`Skipping invalid suggestion at index ${index}:`, question);
                    return; // Skip empty or non-string suggestions
                }
                const chip = document.createElement('div');
                chip.className = 'example-chip';
                chip.setAttribute('data-q', question);
                chip.setAttribute('role', 'button');
                chip.tabIndex = 0; // Make it focusable
                chip.setAttribute('aria-label', `Ask: ${question}`);
                chip.textContent = question;
                chip.addEventListener('click', handleExampleClick);
                chip.addEventListener('keypress', (e) => { // Allow activation with Enter/Space
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault(); // Prevent default space scroll
                        handleExampleClick(e);
                    }
                });
                examplesContainer.appendChild(chip);
            });

            // Animate the chips appearing
            anime({
                targets: '.example-chip',
                translateX: [-20, 0],
                opacity: [0, 1],
                delay: anime.stagger(100), // Stagger animation
                duration: 600,
                easing: 'easeOutQuad'
            });
        }

        // --- Utilities ---

        // *** MODIFIED: Generate search URL on planetbeauty.com ***
        function formatProductUrl(productName) {
            if (!productName || typeof productName !== 'string') {
                return PLANET_BEAUTY_URL; // Link to base URL if no name
            }
            // Create a search URL on the client's website
            const searchUrl = new URL('/search', PLANET_BEAUTY_URL); // Use URL constructor for safety
            searchUrl.searchParams.set('q', productName.trim()); // Add product name as search query
            return searchUrl.toString();
        }


        function getBackupImage(query) {
            const queryLower = (query || "").toLowerCase();
            // Try finding category based on query/product name
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => queryLower.includes(keyword))) {
                    const imageArray = backupImages[category] || [];
                    if (imageArray.length > 0) {
                        // Return a random image from that category's backups
                        return imageArray[Math.floor(Math.random() * imageArray.length)];
                    }
                }
            }
            // Default fallback image if no category match
            return backupImages.default;
        }

        // --- Event Handlers ---
        function handleExampleClick(event) {
            const query = event.currentTarget.getAttribute('data-q');
            if (query) {
                chatInput.value = query;
                updateSendButtonState();
                sendMessage(); // Send the message automatically
                if (typeof gtag === 'function') {
                    gtag('event', 'example_chip_click', { event_category: 'Chatbot', event_label: query });
                }
            }
        }

        function handleInputKeyup(event) {
            // Send message on Enter key press if input is not empty and button is enabled
            if (event.key === 'Enter' && !sendBtn.disabled) {
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            }
        }

        function handleInputChange() {
            updateSendButtonState(); // Enable/disable send button based on input
        }

        function updateSendButtonState() {
            // Disable button if input is empty or only whitespace
            sendBtn.disabled = chatInput.value.trim() === '';
        }

        // --- Core Functions ---
        async function sendMessage() {
            const rawMessage = chatInput.value.trim();
            if (!rawMessage) return; // Don't send empty messages

            // Sanitize user input before displaying
            const message = DOMPurify.sanitize(rawMessage, { USE_PROFILES: { html: false } }); // Disallow HTML in user messages
            addMessage(message, 'user');

            // Add sanitized message to history for the API call
            const userMessageEntry = { role: 'user', parts: [{ text: message }] };
            conversationHistory.push(userMessageEntry);

            // Limit conversation history size
            if (conversationHistory.length > MAX_HISTORY * 2) { // Keep last MAX_HISTORY pairs
                conversationHistory = conversationHistory.slice(-MAX_HISTORY * 2);
            }

            // Clear input and disable controls
            chatInput.value = '';
            updateSendButtonState();
            chatInput.disabled = true;
            sendBtn.disabled = true;

            showTypingIndicator(); // Show "Thinking..."

            try {
                // Call the AI API
                const response = await callGeminiAPI();
                // Process the AI's response
                await processResponse(response, message); // Pass user query for context
            } catch (error) {
                console.error('Error during message processing pipeline:', error);
                hideTypingIndicator(); // Hide "Thinking..." on error

                // Determine appropriate error message
                const errorMessage = error.message.includes('timed out')
                    ? "Sorry, the request timed out. Please try again."
                    : error.message.includes('safety settings') // Check for safety blocks
                    ? error.message // Display the specific safety block message
                    : "Sorry, I encountered an issue processing your request. Please try again.";

                displayError(errorMessage); // Show error message with retry option

                // Attempt fallback search if API failed significantly
                console.log("Attempting fallback search due to error.");
                const fallbackProducts = fallbackSearch(message); // Use sanitized message for fallback
                if (fallbackProducts.length > 0) {
                    addMessage("While I had trouble with the specific request, here are some potentially relevant products based on your query:", 'bot');
                    for (const p of fallbackProducts) {
                        await addProductCard(p, message); // Pass user query for image context
                    }
                } else {
                    // Only add this if no other error message was more specific
                    if (!errorMessage.includes("safety settings") && !errorMessage.includes("timed out")) {
                         addMessage("I couldn't find relevant products based on your query using fallback search either.", 'bot');
                    }
                }
            } finally {
                // Re-enable input controls regardless of success or failure
                chatInput.disabled = false;
                updateSendButtonState();
                chatInput.focus(); // Return focus to input field
            }
        }

        async function callGeminiAPI() {
            // Ensure history doesn't exceed limits before sending
            if (conversationHistory.length > MAX_HISTORY * 2) {
                conversationHistory = conversationHistory.slice(-MAX_HISTORY * 2);
            }

            const prompt = createPrompt(); // Generate the full prompt with history
            const payload = {
                contents: prompt,
                generationConfig: {
                    temperature: 0.5, // Slightly adjusted temperature
                    topP: 0.95,
                    topK: 40,
                    maxOutputTokens: 1024,
                    responseMimeType: 'application/json' // Expect JSON response
                },
                safetySettings: [ // Standard safety settings
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                ]
            };

            try {
                const res = await axios.post(GEMINI_API_URL, payload, {
                    headers: { 'Content-Type': 'application/json' },
                    timeout: API_TIMEOUT // Use configured timeout
                });

                // --- Response Handling ---
                if (res.data && res.data.candidates && res.data.candidates[0]) {
                    const candidate = res.data.candidates[0];

                    // Check for safety blocks first
                    if (candidate.finishReason === 'SAFETY') {
                         const safetyRatings = candidate.safetyRatings || [];
                         const blockedCategories = safetyRatings.filter(r => r.blocked).map(r => r.category).join(', ');
                         console.warn(`Request blocked by API due to safety settings. Categories: ${blockedCategories || 'Unknown'}`);
                         throw new Error(`Your request was blocked due to safety settings (${blockedCategories || 'details unavailable'}). Please rephrase your query.`);
                    }

                    // Check for valid content part
                    if (candidate.content && candidate.content.parts && candidate.content.parts[0] && candidate.content.parts[0].text) {
                        const responseText = candidate.content.parts[0].text;
                        let parsedResponse;
                        try {
                            // Clean potential markdown code fences
                            const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                            parsedResponse = JSON.parse(cleanedText);

                            // --- Validate Parsed JSON Structure ---
                            if (typeof parsedResponse !== 'object' || parsedResponse === null ||
                                typeof parsedResponse.text !== 'string' ||
                                typeof parsedResponse.query_type !== 'string' ||
                                !Array.isArray(parsedResponse.products)) {
                                console.error("Parsed API response has invalid structure:", parsedResponse);
                                // Attempt to use the text part if structure is wrong but text exists
                                if (typeof parsedResponse.text === 'string') {
                                     return { text: parsedResponse.text, query_type: 'other', products: [] };
                                }
                                throw new Error("Invalid response structure from AI.");
                            }

                            // Add the valid *parsed* response text to history (as model's turn)
                            // We store the structured JSON text itself if parsing succeeded
                            conversationHistory.push({ role: 'model', parts: [{ text: cleanedText }] });
                            return parsedResponse; // Return the successfully parsed object

                        } catch (parseError) {
                            console.error('JSON Parse Error:', parseError, "Raw Text:", responseText);
                            // If JSON parsing fails, treat the raw text as a simple response
                            const fallbackResponse = { text: responseText, query_type: 'other', products: [] };
                            // Add the raw text to history
                            conversationHistory.push({ role: 'model', parts: [{ text: responseText }] });
                            return fallbackResponse; // Return the fallback structure
                        }
                    }
                }
                // Handle cases where the response structure is unexpected (e.g., no candidates)
                console.error('Unexpected API response format:', res.data);
                throw new Error('Received an unexpected response format from the AI service.');

            } catch (error) {
                // Handle different types of errors (Axios vs other)
                if (axios.isAxiosError(error)) {
                    if (error.code === 'ECONNABORTED' || error.message.toLowerCase().includes('timeout')) {
                         console.error('API Request Error: Timeout.', error.config?.timeout);
                         throw new Error('The request timed out. Please try again.');
                    } else if (error.response) {
                        // API returned an error status code (4xx, 5xx)
                        console.error(`API Error: ${error.response.status}`, error.response.data);
                        const errorMsg = error.response.data?.error?.message || 'Server error';
                        // Check for specific Gemini API key errors
                        if (error.response.status === 400 && errorMsg.includes("API key not valid")) {
                             throw new Error(`API Key Error: The provided API key is not valid. Please check the configuration.`);
                        }
                        throw new Error(`API Error: ${error.response.status} - ${errorMsg}`);
                    } else if (error.request) {
                        // Request was made but no response received (network issue)
                        console.error('API Request Error: No response received.', error.request);
                        throw new Error('Could not connect to the AI service. Please check your network connection.');
                    } else {
                        // Error setting up the request
                        console.error('API Request Setup Error:', error.message);
                        throw new Error(`Request setup error: ${error.message}`);
                    }
                } else {
                    // Non-Axios error (e.g., safety block error thrown above, parsing error re-thrown)
                    console.error('Non-API Error during call:', error);
                    throw error; // Re-throw the original error
                }
            }
        }

        // *** MODIFIED: Updated prompt instructions for relevance ***
        function createPrompt() {
            const systemInstruction = {
                role: 'user', // System-like instruction provided as user role
                parts: [{
                    text: `You are a friendly and helpful AI assistant for Planet Beauty (planetbeauty.com). Your primary goal is to assist users with beauty product queries based *only* on the conceptual Planet Beauty catalog and engage in natural conversation relevant to beauty.

Instructions:
1.  Analyze the user's message and the conversation history.
2.  Determine the query type:
    *   "greeting": For simple greetings (hi, hello, how are you). Respond warmly, ask how you can help with beauty needs.
    *   "product": If the user asks for specific product recommendations (e.g., "moisturizer for dry skin", "shampoo for curly hair", "red light therapy device", "vitamin C serum"), mentions a beauty concern, or asks about product features/availability.
    *   "other": For conversational closings (thank you, bye), questions not about specific products (e.g., store hours - refer them to the website), or unclear queries.
3.  Formulate your response text: Be concise (max 150 words), friendly, and helpful.
4.  Product Recommendations (ONLY for "product" query_type):
    *   Identify the *specific type* of product or concern mentioned (e.g., 'dry skin', 'red light', 'volumizing shampoo').
    *   Select 1-3 relevant products *conceptually* from the Planet Beauty catalog that match the user's specific request.
    *   **Crucially:** If the user asks for a specific type of product (like 'red light device') and you cannot find a suitable match in the conceptual catalog, explicitly state that you couldn't find that specific item at Planet Beauty. Do NOT recommend unrelated products (like moisturizers if they asked for a device). You can offer to help find something else.
    *   List the names of the recommended products in the "products" array. Each item must be an object like {"name": "Exact Product Name"}.
5.  Return Response: Always respond in a valid JSON object format:
    {"text": "Your response message.", "query_type": "greeting|product|other", "products": [{"name": "Product 1"}, {"name": "Product 2"}]}
    The "products" array should be empty for "greeting" and "other" query types, or if no relevant products were found for a "product" query.

Conversation History is provided below for context. Focus on the latest user message.

Examples:
User: Hi
Assistant: {"text": "Hello! Welcome to Planet Beauty. How can I assist you with your beauty needs today? ‚ú®", "query_type": "greeting", "products": []}

User: I need a moisturizer for very dry skin
Assistant: {"text": "Dealing with very dry skin requires deep hydration! Based on Planet Beauty's selection, you might like these options:üíß", "query_type": "product", "products": [{"name": "CeraVe Moisturizing Cream"}, {"name": "First Aid Beauty Ultra Repair Cream"}]}

User: Do you have any red light therapy masks?
Assistant: {"text": "Let me check the Planet Beauty catalog for red light therapy masks. Currently, I don't see specific red light therapy masks listed in our main catalog. However, we have many other skincare tools and treatments! Can I help you find something else?", "query_type": "product", "products": []}
(Example assumes no red light masks are conceptually known)

User: Can you recommend a good vitamin C serum?
Assistant: {"text": "Vitamin C serums are great for brightening! ‚ú® Here are a couple of options available at Planet Beauty:", "query_type": "product", "products": [{"name": "SkinCeuticals C E Ferulic"}, {"name": "Mad Hippie Vitamin C Serum"}]}

User: Thanks!
Assistant: {"text": "You're very welcome! Let me know if anything else comes to mind. üòä", "query_type": "other", "products": []}

User: What time do your stores close?
Assistant: {"text": "As an AI assistant, I don't have access to real-time store hours. For the most accurate store closing times, please check the official Planet Beauty website or contact your local store directly.", "query_type": "other", "products": []}`
                }]
            };
            // Filter history to ensure valid entries before sending
            const validHistory = conversationHistory.filter(entry => entry.role && entry.parts && Array.isArray(entry.parts) && entry.parts[0] && typeof entry.parts[0].text === 'string');
            return [systemInstruction, ...validHistory]; // Combine system instruction with valid history
        }


        function fallbackSearch(query) {
            const queryLower = (query || "").toLowerCase();
            if (!queryLower || !products || products.length === 0) return []; // Guard clauses

            // Basic keyword extraction (improved slightly)
            const stopWords = new Set(['the', 'a', 'an', 'is', 'are', 'for', 'what', 'can', 'you', 'recommend', 'find', 'me', 'i', 'need', 'with', 'of', 'my', 'skin', 'hair', 'product', 'products', 'good', 'best']);
            const keywords = queryLower.split(/[\s,.-]+/) // Split by spaces and common punctuation
                .filter(word => word.length > 2 && !stopWords.has(word));

            if (keywords.length === 0) return []; // No useful keywords found

            let categoryMatches = new Set();
            // Check if query matches any category keywords
            for (const [category, catKeywords] of Object.entries(categoryKeywords)) {
                if (catKeywords.some(kw => queryLower.includes(kw))) {
                    const categoryProducts = productCategories[category] || [];
                    categoryProducts.forEach(product => categoryMatches.add(product));
                }
            }

            // Score products based on keyword matches in name/description and category match
            const scoredProducts = products.map(product => {
                let score = 0;
                const nameLower = (product.name || "").toLowerCase();
                const descLower = (product.description || "").toLowerCase();

                // Boost score if product belongs to a matched category
                if (categoryMatches.has(product)) score += 5;

                // Score based on keyword presence
                keywords.forEach(term => {
                    if (nameLower.includes(term)) score += 3; // Higher score for name match
                    if (descLower.includes(term)) score += 1; // Lower score for description match
                });
                return { product, score };
            });

            // Filter out products with zero score, sort by score descending
            const relevantProducts = scoredProducts
                .filter(item => item.score > 0)
                .sort((a, b) => b.score - a.score)
                .map(item => item.product);

            // Use a Map to ensure uniqueness based on ID or Name as fallback
            const uniqueResults = new Map();
            relevantProducts.forEach(p => {
                 const key = p.id || p.name; // Use ID if available, otherwise name
                 if (!uniqueResults.has(key)) {
                     uniqueResults.set(key, p);
                 }
            });

            // Return top 3 unique results
            return Array.from(uniqueResults.values()).slice(0, 3);
        }


        async function processResponse(response, userQuery) {
            hideTypingIndicator();

            if (!response || typeof response !== 'object') {
                console.error("Invalid response object received in processResponse:", response);
                addMessage("Sorry, I received an unexpected response. Please try again.", 'bot');
                return;
            }

            // Display the AI's text response (sanitized)
            if (response.text) {
                addMessage(DOMPurify.sanitize(response.text, { USE_PROFILES: { html: true } }), 'bot'); // Allow safe HTML like bold/italics if AI uses it
                updateUserProfile(response.text); // Attempt to update profile based on response
            } else {
                // Fallback message if AI provides no text (should be rare with validation)
                addMessage("Okay, let me see what I can find for you.", 'bot');
            }

            let productsToShow = [];
            const queryType = response.query_type || 'other'; // Default to 'other' if missing

            // --- Product Matching Logic ---
            // Only process products if the query type is 'product' and the API provided product names
            if (queryType === 'product' && response.products && Array.isArray(response.products) && response.products.length > 0) {
                console.log("Gemini suggested products:", response.products.map(p => p.name));

                for (const suggestedProduct of response.products) {
                    // Validate suggested product structure
                    if (!suggestedProduct || typeof suggestedProduct.name !== 'string' || !suggestedProduct.name.trim()) {
                        console.warn("Skipping invalid product suggestion from API:", suggestedProduct);
                        continue; // Skip malformed suggestions
                    }

                    const suggestedName = suggestedProduct.name.trim();
                    const suggestedNameLower = suggestedName.toLowerCase();
                    let foundProduct = null;

                    // --- Matching Strategy ---
                    // 1. Exact match (case-insensitive) on product name
                    foundProduct = products.find(p => p.name && p.name.toLowerCase() === suggestedNameLower);

                    // 2. Partial match (if exact fails) - check if names contain each other
                    if (!foundProduct) {
                        foundProduct = products.find(p =>
                            p.name && (p.name.toLowerCase().includes(suggestedNameLower) || suggestedNameLower.includes(p.name.toLowerCase()))
                        );
                    }

                    // --- Add Found Product ---
                    if (foundProduct) {
                        // Ensure product isn't already added (using ID or name as key)
                        const productKey = foundProduct.id || foundProduct.name;
                        if (!productsToShow.some(p => (p.id || p.name) === productKey)) {
                            console.log(`Matched API suggestion "${suggestedName}" to catalog product: ${foundProduct.name}`);
                            productsToShow.push({
                                ...foundProduct, // Spread existing product data
                                // Ensure essential fields have fallbacks
                                name: foundProduct.name || "Unnamed Product",
                                description: foundProduct.description || "Description not available.",
                                price: foundProduct.price || "",
                                image: foundProduct.image, // Use already sanitized image URL
                                // Use provided URL first, then generate search URL as fallback
                                url: foundProduct.url || formatProductUrl(foundProduct.name)
                            });
                        }
                    } else {
                        console.log(`Could not find catalog match for API suggestion "${suggestedName}". Skipping card.`);
                        // Optional: Could add a message saying "I mentioned X, but couldn't find its details."
                    }
                }
            }

            // --- Fallback Search Trigger ---
            // If it was a product query, but API returned no products OR matching failed for all suggestions
            if (queryType === 'product' && productsToShow.length === 0) {
                // Avoid fallback if the AI already said it couldn't find the item
                 if (!response.text || (!response.text.toLowerCase().includes("couldn't find") && !response.text.toLowerCase().includes("don't see specific"))) {
                    console.log("Using fallback search as API provided no usable products or matching failed.");
                    const fallbackProducts = fallbackSearch(userQuery); // Use original user query for fallback

                    if (fallbackProducts.length > 0) {
                        productsToShow = fallbackProducts.map(p => ({
                            ...p,
                            name: p.name || "Unnamed Product",
                            description: p.description || "Description not available.",
                            price: p.price || "",
                            image: p.image,
                            url: p.url || formatProductUrl(p.name) // Generate search URL if none provided
                        }));
                        // Add a message indicating these are fallback results
                        addMessage("Based on your query, these might be relevant from our catalog:", 'bot');
                    } else {
                        // If fallback also fails, and AI didn't already say it couldn't find anything
                        addMessage("I looked through our catalog but couldn't find specific products for that right now. Perhaps try rephrasing or asking about a different category?", 'bot');
                    }
                 } else {
                     console.log("Skipping fallback search because AI response indicated item not found.");
                 }
            }

            // --- Display Product Cards ---
            if (productsToShow.length > 0) {
                const maxCards = 3; // Limit number of cards displayed
                // Use Promise.all to add cards concurrently (improves perceived speed)
                await Promise.all(productsToShow.slice(0, maxCards).map(p => addProductCard(p, userQuery)));
            }
        }


        // --- UI Functions ---
        function addMessage(text, sender) {
            const div = document.createElement('div');
            div.className = sender === 'user' ? 'user-message' : 'bot-message';
            // Sanitize HTML content before inserting
            div.innerHTML = DOMPurify.sanitize(text, { USE_PROFILES: { html: true } }); // Allow basic HTML like links, bold, etc.
            chatArea.appendChild(div);

            // Animate message appearance
            anime({
                targets: div,
                translateY: [10, 0], // Slide up effect
                opacity: [0, 1], // Fade in effect
                duration: 400,
                easing: 'easeOutQuad'
            });

            scrollToBottom(); // Ensure new message is visible
        }

        function showTypingIndicator() {
            hideTypingIndicator(); // Remove any existing indicator first
            const div = document.createElement('div');
            div.id = 'typing-indicator';
            div.className = 'bot-message'; // Style like a bot message
            // Use FontAwesome spinner for a cleaner look
            div.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i> Thinking...`;
            chatArea.appendChild(div);
            scrollToBottom();
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                indicator.remove();
            }
        }

        function displayError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message animate-fade-in'; // Add animation
            // Sanitize the error message before displaying
            errorDiv.innerHTML = DOMPurify.sanitize(`
                <i class="fas fa-exclamation-circle mr-2"></i> ${message}
                <button class="retry-btn block mt-2 text-pink-600 underline" aria-label="Retry last message">Try Again</button>
            `); // Make retry button block for better click area

            const retryBtn = errorDiv.querySelector('.retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', () => {
                    // Find the last actual user message sent
                    const lastUserMessage = [...conversationHistory].reverse().find(m => m.role === 'user');
                    if (lastUserMessage && lastUserMessage.parts[0].text) {
                        chatInput.value = lastUserMessage.parts[0].text; // Restore message to input
                        updateSendButtonState();
                        sendMessage(); // Resend the message
                    } else {
                        addMessage("Could not retrieve the last message to retry.", 'bot');
                    }
                    errorDiv.remove(); // Remove the error message on retry
                });
            }

            chatArea.appendChild(errorDiv);
            scrollToBottom();
        }

        // --- Product Card Display ---
        async function addProductCard(p, queryContext) {
            const card = document.createElement('a');
            // Use the URL from the product data if available, otherwise generate search URL
            card.href = p.url || formatProductUrl(p.name);
            card.target = '_blank'; // Open in new tab
            card.rel = 'noopener noreferrer'; // Security best practice
            card.className = 'product-card animate-fade-in'; // Add fade-in animation
            card.setAttribute('aria-label', `View product: ${p.name || 'Unknown Product'}`); // Accessibility
            card.addEventListener('click', () => {
                // Track product clicks in analytics
                if (typeof gtag === 'function') {
                    gtag('event', 'product_click', {
                        event_category: 'Chatbot',
                        event_label: p.name || 'Unknown Product',
                        value: p.price // Optionally track price
                     });
                }
            });

            // --- Image Loading with Placeholder & Fallback ---
            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-loading'; // Shows spinner initially
            const spinner = document.createElement('div');
            spinner.className = 'spinner';
            imageContainer.appendChild(spinner);
            card.appendChild(imageContainer); // Add container with spinner first

            const img = document.createElement('img');
            img.alt = p.name ? `Image of ${p.name}` : "Product Image";
            img.className = 'product-image lazyload'; // Add lazyload class
            img.style.display = 'none'; // Hide initially until loaded

            // Define potential image sources in order of preference
            const imageSources = [
                p.image, // Primary image from data
                getBackupImage(p.name || queryContext), // Backup based on name/query
                backupImages.default // Absolute default placeholder
            ].filter(url => url && typeof url === 'string' && url.trim() !== ''); // Filter out invalid URLs

            let currentAttempt = 0;

            const tryLoadNextImage = () => {
                if (currentAttempt >= imageSources.length) {
                    // All attempts failed, show placeholder
                    console.warn(`Failed to load any image for product: ${p.name || 'Unknown'}`);
                    imageContainer.innerHTML = `
                        <div class="image-placeholder">
                            <span>Image Not Available</span>
                        </div>`;
                    // Ensure placeholder is visible if spinner was already replaced
                    if (!card.contains(imageContainer)) {
                         const infoDiv = card.querySelector('.product-info');
                         if (infoDiv) card.insertBefore(imageContainer, infoDiv);
                         else card.appendChild(imageContainer);
                    }
                    return; // Stop trying
                }

                const url = imageSources[currentAttempt];
                console.log(`Image Attempt ${currentAttempt + 1} for ${p.name || 'Unknown'}: Trying URL ${url}`);

                // Clear previous handlers
                img.onload = null;
                img.onerror = null;

                img.onload = () => {
                    console.log(`Image loaded successfully: ${img.src}`);
                    img.style.display = 'block'; // Show the image
                    // Replace the spinner container with the loaded image
                    if (imageContainer.parentNode) {
                        imageContainer.replaceWith(img);
                    }
                    img.classList.add('lazyloaded'); // Mark as loaded for potential CSS transitions
                };

                img.onerror = () => {
                    console.warn(`Image Attempt ${currentAttempt + 1} for ${p.name || 'Unknown'}: URL ${url} failed.`);
                    currentAttempt++;
                    tryLoadNextImage(); // Try the next source
                };

                // Set the src to trigger loading (or use data-src for lazysizes)
                img.setAttribute('data-src', url); // Use data-src for lazysizes
                img.src = url; // Set src directly as fallback / trigger
            };

            tryLoadNextImage(); // Start the image loading process

            // --- Product Info ---
            const MAX_TITLE_LENGTH = 60; // Slightly longer title allowed
            const MAX_DESC_LENGTH = 120; // Slightly longer description allowed

            const productName = p.name || "Unnamed Product";
            const productDesc = p.description || "Click to view details on PlanetBeauty.com"; // More informative default

            // Truncate long text and add ellipsis
            const truncatedName = productName.length > MAX_TITLE_LENGTH
                ? productName.substring(0, MAX_TITLE_LENGTH) + '...'
                : productName;
            const truncatedDesc = productDesc.length > MAX_DESC_LENGTH
                ? productDesc.substring(0, MAX_DESC_LENGTH) + '...'
                : productDesc;

            const infoDiv = document.createElement('div');
            infoDiv.className = 'product-info';
            // Sanitize text content before inserting
            infoDiv.innerHTML = DOMPurify.sanitize(`
                <div class="product-name" title="${DOMPurify.sanitize(productName, { USE_PROFILES: { html: false } })}">${DOMPurify.sanitize(truncatedName, { USE_PROFILES: { html: false } })}</div>
                <div class="product-description">${DOMPurify.sanitize(truncatedDesc, { USE_PROFILES: { html: false } })}</div>
                <div class="product-price">${p.price ? DOMPurify.sanitize(p.price, { USE_PROFILES: { html: false } }) : ""}</div>
            `, { USE_PROFILES: { html: false } }); // Sanitize all parts strictly

            card.appendChild(infoDiv); // Add info section below image/placeholder
            chatArea.appendChild(card); // Add the complete card to the chat
            scrollToBottom(); // Ensure card is visible
        }


        function scrollToBottom() {
            // Use requestAnimationFrame for smoother scrolling after DOM updates
            requestAnimationFrame(() => {
                chatArea.scrollTop = chatArea.scrollHeight;
            });
        }

        // --- User Profile (Simple Example) ---
        // This is a basic example; a real implementation might involve more sophisticated NLP
        function updateUserProfile(botResponseText) {
            if (typeof botResponseText !== 'string') return;

            const textLower = botResponseText.toLowerCase();
            let updated = false;
            const newProfile = { ...userProfile }; // Copy current profile

            // Simple keyword checks to infer profile attributes
            if (textLower.includes('dry skin') && newProfile.skinType !== 'Dry') {
                newProfile.skinType = 'Dry'; updated = true;
            } else if (textLower.includes('oily skin') && newProfile.skinType !== 'Oily') {
                newProfile.skinType = 'Oily'; updated = true;
            } else if (textLower.includes('combination skin') && newProfile.skinType !== 'Combination') {
                newProfile.skinType = 'Combination'; updated = true;
            } else if (textLower.includes('sensitive skin') && newProfile.skinType !== 'Sensitive') {
                newProfile.skinType = 'Sensitive'; updated = true;
            }

            if (textLower.includes('acne') && !newProfile.concerns.includes('Acne')) {
                newProfile.concerns.push('Acne'); updated = true;
            }
            if ((textLower.includes('wrinkles') || textLower.includes('fine lines') || textLower.includes('aging')) && !newProfile.concerns.includes('Aging')) {
                newProfile.concerns.push('Aging'); updated = true;
            }
            if (textLower.includes('dullness') && !newProfile.concerns.includes('Dullness')) {
                newProfile.concerns.push('Dullness'); updated = true;
            }
            // Add more concerns as needed (e.g., redness, pores)

            if (updated) {
                Object.assign(userProfile, newProfile); // Update the main profile object
                console.log(`User profile updated - Skin Type: ${userProfile.skinType || 'N/A'}, Concerns: ${userProfile.concerns.length > 0 ? userProfile.concerns.join(', ') : 'None'}`);
                // Potentially use this profile info in future prompts
            }
        }
    </script>
</body>
</html>
