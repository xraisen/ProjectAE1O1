<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Planet Beauty AI Chatbot - Find personalized beauty products with our interactive assistant.">
    <!-- FIX: Added Favicon Link -->
    <link rel="icon" href="https://via.placeholder.com/16x16/E91e63/FFFFFF?text=PB" type="image/png">
    <title>Planet Beauty AI Chatbot</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX'); // Replace with your GA ID
    </script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f8f9fa;
            margin: 0;
            overflow-x: hidden;
        }
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #e91e63;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .chat-container {
            max-width: 900px;
            margin: 0 auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 12px;
            background: white;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 140px);
            max-height: 800px;
        }
        .chat-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
            will-change: scroll-position;
        }
        .user-message {
            background: #e91e63;
            color: white;
            padding: .75rem 1rem;
            border-radius: 15px 15px 0 15px;
            max-width: 80%;
            margin-left: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .bot-message {
            background: #f0f0f0;
            color: #333;
            padding: .75rem 1rem;
            border-radius: 15px 15px 15px 0;
            max-width: 80%;
            margin-right: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .product-card {
            display: block;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            margin: 1rem 0;
            text-decoration: none;
            color: inherit;
            background: white;
            max-width: 80%;
            margin-right: auto;
        }
        .product-card:hover {
            transform: scale(1.03);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .product-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }
        .lazyload, .lazyloading {
            opacity: 0;
            transition: opacity 0.3s;
        }
        .lazyloaded {
            opacity: 1;
        }
        .image-loading {
            position: relative;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f5f5f5;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(233, 30, 99, 0.2);
            border-top-color: #e91e63;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .image-placeholder {
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #eee;
            color: #666;
            font-size: 0.9em;
            text-align: center;
        }
        .product-info {
            padding: 1rem;
        }
        .product-name {
            font-weight: 600;
            margin-bottom: .25rem;
        }
        .product-description {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: .5rem;
        }
        .product-price {
            font-weight: 500;
            color: #e91e63;
        }
        .examples-container {
            display: flex;
            flex-wrap: wrap;
            gap: .5rem;
            margin-bottom: 1rem;
            max-width: 80%;
        }
        .example-chip {
            padding: .5rem 1rem;
            background: #f0f0f0;
            border: 1px solid #e0e0e0;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s, box-shadow 0.2s;
            font-size: 0.9rem;
        }
        .example-chip:hover {
            background: #e91e63;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .example-chip:focus {
            outline: 2px solid #e91e63;
            outline-offset: 2px;
        }
        .input-area {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #eee;
            background: #fff;
        }
        .input-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        input[type=text] {
            flex: 1;
            padding: .75rem 1rem;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            transition: border-color 0.3s;
        }
        input[type=text]:focus {
            border-color: #e91e63;
        }
        input[type=text]:disabled {
            background-color: #f5f5f5;
        }
        .send-btn {
            background: #e91e63;
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            flex-shrink: 0;
        }
        .send-btn:hover {
            background: #d81b60;
            transform: scale(1.05);
        }
        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: .75rem 1rem;
            border-radius: 15px;
            margin-bottom: 1rem;
            max-width: 80%;
            margin-right: auto;
            border: 1px solid #f4c7c7;
        }
        .retry-btn {
            background: none;
            border: none;
            color: #e91e63;
            text-decoration: underline;
            cursor: pointer;
        }
        footer {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 0.5rem 1rem;
            color: #6c757d;
            font-size: 0.875rem;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        footer a {
            color: #e91e63;
            text-decoration: none;
            margin-left: 0.25rem;
        }
        footer a:hover {
            text-decoration: underline;
        }
        #typing-indicator .typing-dots {
            display: inline-block;
            width: 1.5em;
            text-align: left;
            vertical-align: bottom;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @media (max-width: 640px) {
            body {
                padding: 0;
            }
            .chat-container {
                border-radius: 0;
                max-width: 100%;
                height: 100vh;
                max-height: none;
                margin: 0;
            }
            .chat-area {
                padding: 1rem;
            }
            .user-message, .bot-message, .product-card, .examples-container, .error-message {
                max-width: 90%;
            }
            .input-area {
                padding: 0.75rem;
            }
            input[type=text] {
                padding: 0.6rem 0.9rem;
            }
            .send-btn {
                width: 40px;
                height: 40px;
            }
            footer {
                font-size: 0.8rem;
                padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <div id="preloader"><div class="spinner"></div></div>
    <header class="text-center py-6 px-4 flex-shrink-0 bg-gradient-to-r from-pink-600 to-purple-700 text-white shadow-md animate-fade-in">
        <h1 class="text-3xl sm:text-4xl font-bold">Planet Beauty</h1>
        <p class="text-lg sm:text-xl">Your AI Beauty Assistant ✨</p>
    </header>

    <main class="chat-container flex-grow animate-fade-in">
        <div id="chat-area" class="chat-area">
            <div class="bot-message">Hi there! Welcome to Planet Beauty's AI Assistant. ✨ How can I help you find the perfect products today?</div>
            <div id="examples-container" class="examples-container"></div>
        </div>

        <div class="input-area">
            <div class="input-row">
                <input id="chat-input" type="text" placeholder="Ask about beauty products..." autocomplete="off" aria-label="Type your beauty product question">
                <button id="send-btn" class="send-btn" disabled aria-label="Send message"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </main>

    <footer>
        <span>Developed with ❤️ by</span>
        <a href="https://www.linkedin.com/in/joseespinosa" target="_blank" rel="noopener noreferrer">Jose Espinosa</a>
    </footer>

    <script>
        // --- Configuration ---
        const GEMINI_API_KEY = 'AIzaSyCpI-eNfqWk_ZiK2qHOj_tD2NzeAJ_U398'; // Replace with your Gemini API key
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzzp5mD6Nu3RZmYvjzDFXvCNC5MhJyfNMvs_MJDYLqZ8Uad1BJE-cO1WWg7BpoYO62_/exec'; // Replace with your deployed Web App URL
        const API_TIMEOUT = 15000;
        const IMAGE_TIMEOUT = 15000; // Increased timeout (already present in original code)

        // --- Fallback Questions ---
        const FALLBACK_QUESTIONS = [
            "What products are best for sensitive skin?",
            "Can you recommend a conditioner for curly hair?",
            "What's a good cleanser for combination skin?",
            "Which makeup is ideal for a natural look?"
        ];

        // --- State ---
        const userProfile = { skinType: null, skinTone: null, concerns: [] };
        let conversationHistory = [];
        const MAX_HISTORY = 6;
        // NOTE: imageCache is no longer used by the simplified addProductCard, but kept here for potential future use or if other parts rely on it.
        const imageCache = JSON.parse(localStorage.getItem('imageCache')) || {};
        let products = [];
        let productCategories = {};
        const backupImages = {
            default: 'https://via.placeholder.com/600x400/E91e63/FFFFFF?text=Planet+Beauty',
        };

        // --- Category Keywords ---
        const categoryKeywords = {
            acne: ['acne', 'blemish', 'pimple', 'breakout', 'clear skin', 'oily'],
            moisturizer: ['moisturizer', 'hydrating', 'dry skin', 'hydration', 'cream'],
            shampoo: ['shampoo', 'hair wash', 'clean hair'],
            conditioner: ['conditioner', 'soften hair', 'detangle'],
            hairmask: ['hair mask', 'treatment', 'damaged hair', 'repair hair'],
            foundation: ['foundation', 'makeup base', 'cover', 'complexion', 'tone'],
            serum: ['serum', 'treatment', 'concentrate'],
            cleanser: ['cleanser', 'face wash', 'wash'],
            exfoliant: ['exfoliant', 'scrub', 'peel', 'smooth skin'],
            styling: ['styling', 'hairspray', 'texture', 'volume', 'hold'],
            skincare: ['skincare', 'face care', 'complexion', 'skin health'],
            haircare: ['haircare', 'hair product', 'mane'],
            sunscreen: ['sunscreen', 'spf', 'uv', 'protection']
        };

        // --- DOM Elements ---
        const chatArea = document.getElementById('chat-area');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const preloader = document.getElementById('preloader');
        const examplesContainer = document.getElementById('examples-container');

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            setTimeout(() => {
                preloader.style.opacity = '0';
                setTimeout(() => preloader.remove(), 500);
            }, 1000);

            anime({
                targets: 'header',
                translateY: [-20, 0],
                opacity: [0, 1],
                duration: 800,
                easing: 'easeOutQuad'
            });

            products = await fetchProducts();
            categorizeProducts();
            await generateSuggestedQuestions();

            chatInput.addEventListener('keyup', handleInputKeyup);
            chatInput.addEventListener('input', handleInputChange);
            sendBtn.addEventListener('click', () => {
                sendMessage();
                // Ensure gtag is defined before calling (it should be from the script tag)
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            });
            chatInput.focus();
            updateSendButtonState();
        });

        // --- Fetch Products from Google Apps Script Web App ---
        async function fetchProducts() {
            try {
                const res = await axios.get(WEB_APP_URL);
                if (res.data && res.data.products) {
                    products = res.data.products.map((p, index) => ({
                        ...p,
                        id: p.id || `p${index + 1}`,
                        // Ensure image URL uses https
                        image: p.image && typeof p.image === 'string' && p.image.startsWith('http://') ? p.image.replace('http://', 'https://') : p.image
                    }));
                    console.log("Products loaded from Web App:", products.length);
                    return products;
                } else if (res.data && res.data.error) {
                    throw new Error(`Web App Error: ${res.data.error}`);
                } else {
                    throw new Error("Invalid data format received from Web App.");
                }
            } catch (error) {
                console.error('Failed to fetch products:', error);
                addMessage("Sorry, I couldn't load the product catalog right now. Please try again later.", 'bot');
                return [];
            }
        }

        // --- Categorize Products ---
        function categorizeProducts() {
            if (!products || products.length === 0) return; // Guard against empty products array
            products.forEach(product => {
                product.categories = [];
                for (const [category, keywords] of Object.entries(categoryKeywords)) {
                    if (keywords.some(keyword =>
                        (product.name && typeof product.name === 'string' && product.name.toLowerCase().includes(keyword)) ||
                        (product.description && typeof product.description === 'string' && product.description.toLowerCase().includes(keyword)))) {
                        product.categories.push(category);
                    }
                }
            });
            // Create category map
            productCategories = Object.fromEntries(
                Object.keys(categoryKeywords).map(category => [
                    category,
                    products.filter(p => p.categories && p.categories.includes(category))
                ])
            );
            // Populate backup images per category
            for (const category of Object.keys(productCategories)) {
                backupImages[category] = productCategories[category]
                    .map(p => p.image)
                    .filter(img => img && typeof img === 'string'); // Ensure only valid image strings are added
            }
        }


        // --- Suggested Questions ---
        async function generateSuggestedQuestions() {
            try {
                const questions = await fetchSuggestedQuestions();
                displaySuggestedQuestions(questions);
            } catch (error) {
                console.error('Failed to generate suggested questions:', error);
                displaySuggestedQuestions(FALLBACK_QUESTIONS);
            }
        }

        async function fetchSuggestedQuestions() {
            const prompt = {
                contents: [{
                    role: 'user',
                    parts: [{
                        text: `Generate 4 concise, varied, and helpful beauty-related questions for a chatbot. Questions should be relevant to skincare, haircare, or makeup, addressing common user needs (e.g., product recommendations for specific skin types or hair concerns). Return the response as a JSON array of strings. Example:
                        ["What's the best moisturizer for oily skin?", "Can you recommend a shampoo for dry hair?", "What foundation suits sensitive skin?", "Which serum helps with fine lines?"]`
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topP: 0.95,
                    topK: 40,
                    maxOutputTokens: 256,
                    responseMimeType: 'application/json'
                },
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                ]
            };

            const res = await axios.post(GEMINI_API_URL, prompt, {
                headers: { 'Content-Type': 'application/json' },
                timeout: API_TIMEOUT
            });

            if (res.data && res.data.candidates && res.data.candidates[0] &&
                res.data.candidates[0].content && res.data.candidates[0].content.parts &&
                res.data.candidates[0].content.parts[0] && res.data.candidates[0].content.parts[0].text) {
                const responseText = res.data.candidates[0].content.parts[0].text;
                try {
                    // Attempt to clean potential markdown/formatting issues before parsing
                    const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                    const questions = JSON.parse(cleanedText);
                    if (Array.isArray(questions) && questions.length >= 4 && questions.every(q => typeof q === 'string')) {
                        return questions.slice(0, 4);
                    } else {
                         console.error('Parsed questions are not in the expected format:', questions);
                    }
                } catch (parseError) {
                    console.error('JSON Parse Error for questions:', parseError, 'Raw text:', responseText);
                }
            }
            throw new Error('Failed to fetch valid questions from API.');
        }


        function displaySuggestedQuestions(questions) {
            examplesContainer.innerHTML = ''; // Clear previous suggestions
            if (!Array.isArray(questions)) {
                console.error("Cannot display suggestions: input is not an array.", questions);
                questions = FALLBACK_QUESTIONS; // Use fallback if input is invalid
            }
            questions.forEach((question, index) => {
                if (typeof question !== 'string') {
                    console.warn(`Skipping invalid suggestion at index ${index}:`, question);
                    return; // Skip non-string items
                }
                const chip = document.createElement('div');
                chip.className = 'example-chip';
                chip.setAttribute('data-q', question);
                chip.setAttribute('role', 'button');
                chip.tabIndex = 0; // Make it focusable
                chip.setAttribute('aria-label', `Ask: ${question}`);
                chip.textContent = question;
                chip.addEventListener('click', handleExampleClick);
                chip.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault(); // Prevent default space scroll / enter submit
                        handleExampleClick(e);
                    }
                });
                examplesContainer.appendChild(chip);
            });

            // Animate the chips
            anime({
                targets: '.example-chip',
                translateX: [-20, 0],
                opacity: [0, 1],
                delay: anime.stagger(100),
                duration: 600,
                easing: 'easeOutQuad'
            });
        }


        // --- Utilities ---

        // FIX: Removed isValidImageUrl function

        function formatProductUrl(productName) {
            if (!productName || typeof productName !== 'string') return '#'; // Basic validation
            return 'https://www.planetbeauty.com/products/' +
                productName.toLowerCase()
                    .replace(/[^\w\s-]/g, '') // Remove invalid chars
                    .trim()
                    .replace(/\s+/g, '-') // Replace spaces with hyphens
                    .replace(/-+/g, '-'); // Replace multiple hyphens with single
        }

        function getBackupImage(query) { // Removed productCategories param as it's globally accessible
            const queryLower = (query || "").toLowerCase(); // Ensure query is a string and lowercase
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => queryLower.includes(keyword))) {
                    const imageArray = backupImages[category] || [];
                    if (imageArray.length > 0) {
                        // Return a random image from the category's backup list
                        return imageArray[Math.floor(Math.random() * imageArray.length)];
                    }
                }
            }
            // If no category match or category has no backup images, return the default
            return backupImages.default;
        }


        // --- Event Handlers ---
        function handleExampleClick(event) {
            // Use currentTarget to ensure we get the element the listener was attached to
            const query = event.currentTarget.getAttribute('data-q');
            if (query) {
                chatInput.value = query;
                updateSendButtonState();
                sendMessage();
                // Ensure gtag is defined
                if (typeof gtag === 'function') {
                    gtag('event', 'example_chip_click', { event_category: 'Chatbot', event_label: query });
                }
            }
        }


        function handleInputKeyup(event) {
            if (event.key === 'Enter' && !sendBtn.disabled) {
                sendMessage();
                // Ensure gtag is defined
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            }
        }

        function handleInputChange() {
            updateSendButtonState();
        }

        function updateSendButtonState() {
            sendBtn.disabled = chatInput.value.trim() === '';
        }

        // --- Core Functions ---
        async function sendMessage() {
            const rawMessage = chatInput.value.trim();
            if (!rawMessage) return;

            // Sanitize user input before displaying or processing
            const message = DOMPurify.sanitize(rawMessage, { USE_PROFILES: { html: true } });

            addMessage(message, 'user');
            const userMessageEntry = { role: 'user', parts: [{ text: message }] }; // Use sanitized message for history too? Or raw? Let's use sanitized for consistency.
            conversationHistory.push(userMessageEntry);

            // Keep history concise
            if (conversationHistory.length > MAX_HISTORY * 2) { // Keep user+model pairs
                 conversationHistory = conversationHistory.slice(-MAX_HISTORY * 2);
            }


            chatInput.value = '';
            updateSendButtonState();
            chatInput.disabled = true;
            sendBtn.disabled = true;

            showTypingIndicator();

            try {
                const response = await callGeminiAPI(userMessageEntry); // Pass only the latest message? No, API needs history.
                await processResponse(response, message); // Pass user query for context
            } catch (error) {
                console.error('Error during message processing pipeline:', error);
                hideTypingIndicator();
                // Provide a more specific error message if possible
                const errorMessage = error.message.includes('timed out')
                    ? "Sorry, the request timed out. Please try again."
                    : "Sorry, I encountered an issue processing your request. Please try again.";
                displayError(errorMessage);

                // Attempt fallback search even on error
                console.log("Attempting fallback search due to error.");
                const fallbackProducts = fallbackSearch(message);
                if (fallbackProducts.length > 0) {
                    addMessage("While I had trouble with the specific request, here are some potentially relevant products based on your query:", 'bot');
                    for (const p of fallbackProducts) {
                       await addProductCard(p, message); // Add await here
                    }
                } else {
                    addMessage("I couldn't find relevant products based on your query.", 'bot');
                }
            } finally {
                chatInput.disabled = false;
                updateSendButtonState();
                chatInput.focus();
            }
        }


        async function callGeminiAPI() { // Removed lastUserMessage param, uses global history
             // Ensure history doesn't exceed limits (check again before API call)
            if (conversationHistory.length > MAX_HISTORY * 2) {
                conversationHistory = conversationHistory.slice(-MAX_HISTORY * 2);
            }

            const prompt = createPrompt(); // createPrompt uses the global conversationHistory
            const payload = {
                contents: prompt,
                generationConfig: {
                    temperature: 0.4,
                    topP: 0.95,
                    topK: 40,
                    maxOutputTokens: 1024,
                    responseMimeType: 'application/json'
                },
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                ]
            };

            try {
                const res = await axios.post(GEMINI_API_URL, payload, {
                    headers: { 'Content-Type': 'application/json' },
                    timeout: API_TIMEOUT
                });

                if (res.data && res.data.candidates && res.data.candidates[0] &&
                    res.data.candidates[0].content && res.data.candidates[0].content.parts &&
                    res.data.candidates[0].content.parts[0] && res.data.candidates[0].content.parts[0].text) {

                    const responseText = res.data.candidates[0].content.parts[0].text;
                    let parsedResponse;
                    try {
                         // Clean potential markdown before parsing
                        const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                        parsedResponse = JSON.parse(cleanedText);

                        // Basic validation of the parsed response structure
                        if (typeof parsedResponse !== 'object' || parsedResponse === null || typeof parsedResponse.text !== 'string' || typeof parsedResponse.query_type !== 'string' || !Array.isArray(parsedResponse.products)) {
                             console.error("Parsed API response has invalid structure:", parsedResponse);
                             throw new Error("Invalid response structure from API.");
                        }

                        // Add valid model response to history
                        conversationHistory.push({ role: 'model', parts: [{ text: cleanedText }] }); // Store the cleaned JSON string
                        return parsedResponse;

                    } catch (parseError) {
                        console.error('JSON Parse Error:', parseError, "Raw Text:", responseText);
                        // If parsing fails, treat the raw text as a simple response
                        const fallbackResponse = { text: responseText, query_type: 'other', products: [] };
                        conversationHistory.push({ role: 'model', parts: [{ text: responseText }] }); // Store raw text on parse failure
                        return fallbackResponse;
                    }
                } else if (res.data && res.data.promptFeedback && res.data.promptFeedback.blockReason) {
                     // Handle safety blocks
                     console.warn(`Request blocked by API: ${res.data.promptFeedback.blockReason}`);
                     throw new Error(`Your request was blocked due to safety settings (${res.data.promptFeedback.blockReason}). Please rephrase your query.`);
                } else {
                    // Handle other unexpected API response formats
                    console.error('Unexpected API response format:', res.data);
                    throw new Error('Received an unexpected response format from the AI service.');
                }
            } catch (error) {
                 // Centralized error handling for API call
                if (axios.isAxiosError(error)) {
                    if (error.response) {
                        // The request was made and the server responded with a status code
                        // that falls out of the range of 2xx
                        console.error(`API Error: ${error.response.status}`, error.response.data);
                        throw new Error(`API Error: ${error.response.status} - ${error.response.data?.error?.message || 'Server error'}`);
                    } else if (error.request) {
                        // The request was made but no response was received (e.g., timeout)
                        console.error('API Request Error: No response received.', error.request);
                        throw new Error('The request timed out. Please try again.');
                    } else {
                        // Something happened in setting up the request that triggered an Error
                        console.error('API Request Setup Error:', error.message);
                        throw new Error(`Request setup error: ${error.message}`);
                    }
                } else {
                     // Non-Axios errors (like the safety block error thrown above)
                     console.error('Non-API Error during call:', error);
                     throw error; // Re-throw the original error
                }
            }
        }


        function createPrompt() {
            const systemInstruction = {
                role: 'user', // System instructions are often better placed here for Gemini
                parts: [{
                    text: `You are a friendly AI assistant for Planet Beauty. Your goal is to assist users with beauty product queries and engage in natural conversation. For each user message, determine the query type and respond accordingly.

- If the user is greeting or engaging in casual conversation (e.g., "hi," "hello," "how are you"), set "query_type": "greeting" and respond with a friendly message without recommending products.
- If the user is asking for product recommendations or mentioning a beauty concern, set "query_type": "product" and provide a concise response (max 150 words) along with 1-3 product recommendations in the "products" array. Each product in the array should be an object with a "name" key (e.g., {"name": "Product Name"}). Only include the product name.
- For other types of messages (e.g., thank you, goodbye, questions not about products), set "query_type": "other" and respond appropriately without product recommendations.

Always return your response as a valid JSON object containing "text" (your reply), "query_type" (greeting, product, or other), and "products" (an array, possibly empty). Use the conversation history provided for context.

Examples:
1. User: Hi
Assistant: {"text": "Hello! How can I assist you with your beauty needs today?", "query_type": "greeting", "products": []}
2. User: I need a moisturizer for dry skin
Assistant: {"text": "For dry skin, hydration is key! You might like these options: ✨", "query_type": "product", "products": [{"name": "CeraVe Moisturizing Cream"}, {"name": "Borghese Energia Retinol Renewal Night Oil"}]}
3. User: Thank you!
Assistant: {"text": "You're very welcome! Is there anything else I can help you find?", "query_type": "other", "products": []}
4. User: Bye
Assistant: {"text": "Goodbye! Have a beautiful day!", "query_type": "other", "products": []}
5. User: Hi, can you recommend a shampoo for oily hair?
Assistant: {"text": "Hi there! For oily hair, balancing shampoos can help. Consider these: ✨", "query_type": "product", "products": [{"name": "Shea Moisture Coconut & Hibiscus Curl & Shine Shampoo"}]}
6. User: What time do you close?
Assistant: {"text": "I'm an AI assistant, so I don't have store hours! For Planet Beauty's store hours, please check their official website.", "query_type": "other", "products": []}`
                }]
            };
            // Combine system instruction with conversation history
            // Ensure history format matches API expectations (alternating user/model roles)
            const validHistory = conversationHistory.filter(entry => entry.role && entry.parts && Array.isArray(entry.parts));
            return [systemInstruction, ...validHistory];
        }


        function fallbackSearch(query) {
            const queryLower = (query || "").toLowerCase();
            if (!queryLower || products.length === 0) return []; // Handle empty query or no products

            const keywords = queryLower.split(/\s+/)
                                     .filter(word => word.length > 2 && !['the', 'a', 'an', 'is', 'for', 'what', 'can', 'you', 'recommend', 'find', 'me', 'i', 'need', 'with', 'of', 'my', 'skin', 'hair'].includes(word)); // Filter common words

            let categoryMatches = new Set(); // Use a Set to avoid duplicate products initially
            for (const [category, catKeywords] of Object.entries(categoryKeywords)) {
                if (catKeywords.some(kw => queryLower.includes(kw))) {
                    const categoryProducts = productCategories[category] || [];
                    categoryProducts.forEach(product => categoryMatches.add(product));
                }
            }

            // Convert Set to Array
            let matchedProducts = Array.from(categoryMatches);

            // If category matching yields enough results, return them (up to 3)
            if (matchedProducts.length >= 2) {
                 return matchedProducts.slice(0, 3);
            }

            // If not enough category matches, perform keyword scoring on all products
            const scoredProducts = products.map(product => {
                let score = 0;
                const nameLower = (product.name || "").toLowerCase();
                const descLower = (product.description || "").toLowerCase();

                // Boost score if it was already a category match
                if (categoryMatches.has(product)) score += 5;

                // Score based on keyword presence
                keywords.forEach(term => {
                    if (nameLower.includes(term)) score += 3; // Higher weight for name match
                    if (descLower.includes(term)) score += 1; // Lower weight for description match
                });
                return { product, score };
            });

            // Filter out products with zero score, sort by score descending
            const relevantProducts = scoredProducts
                .filter(item => item.score > 0)
                .sort((a, b) => b.score - a.score)
                .map(item => item.product);

            // Combine category matches and relevant products, ensuring no duplicates
            const combinedResults = new Map(); // Use Map to maintain order and uniqueness
            matchedProducts.forEach(p => combinedResults.set(p.id || p.name, p)); // Add category matches first
            relevantProducts.forEach(p => {
                 if (!combinedResults.has(p.id || p.name)) {
                     combinedResults.set(p.id || p.name, p);
                 }
            });


            // Return the top 3 combined results
            return Array.from(combinedResults.values()).slice(0, 3);
        }


        async function processResponse(response, userQuery) {
            hideTypingIndicator();

            // Ensure response is valid before processing
            if (!response || typeof response !== 'object') {
                console.error("Invalid response object received in processResponse:", response);
                addMessage("Sorry, I received an unexpected response. Please try again.", 'bot');
                return;
            }


            // Display the text response from the API
            if (response.text) {
                // Sanitize HTML content from the bot response before rendering
                addMessage(DOMPurify.sanitize(response.text, { USE_PROFILES: { html: true } }), 'bot');
                updateUserProfile(response.text); // Update profile based on bot's understanding
            } else {
                // Fallback message if API response lacks text
                addMessage("Okay, let me see what I can find for you.", 'bot');
            }

            let productsToShow = [];
            const queryType = response.query_type || 'other'; // Default to 'other' if missing

            // Process products suggested by the API
            if (response.products && Array.isArray(response.products) && response.products.length > 0) {
                console.log("Gemini suggested products:", response.products.map(p => p.name));

                for (const suggestedProduct of response.products) {
                    // Ensure the suggestion is valid
                    if (!suggestedProduct || typeof suggestedProduct.name !== 'string' || !suggestedProduct.name.trim()) {
                         console.warn("Skipping invalid product suggestion from API:", suggestedProduct);
                         continue;
                    }

                    const nameLower = suggestedProduct.name.trim().toLowerCase();
                    let foundProduct = null;

                    // Try exact match first (case-insensitive)
                    foundProduct = products.find(p => p.name && p.name.toLowerCase() === nameLower);

                    // If no exact match, try partial match (more lenient)
                    if (!foundProduct) {
                        foundProduct = products.find(p =>
                            p.name && (p.name.toLowerCase().includes(nameLower) || nameLower.includes(p.name.toLowerCase()))
                        );
                    }

                    if (foundProduct) {
                        // Avoid adding duplicates if API suggests the same product multiple ways
                        if (!productsToShow.some(p => (p.id || p.name) === (foundProduct.id || foundProduct.name))) {
                            console.log(`Matched "${suggestedProduct.name}" to CSV product: ${foundProduct.name}`);
                            productsToShow.push({
                                ...foundProduct, // Spread existing product data
                                // Ensure essential fields have fallbacks
                                name: foundProduct.name || "Unnamed Product",
                                description: foundProduct.description || "Description not available.",
                                price: foundProduct.price || "", // Keep price empty if not available
                                image: foundProduct.image, // Already handled https conversion
                                url: foundProduct.url || formatProductUrl(foundProduct.name) // Generate URL if missing
                            });
                        }
                    } else {
                        console.log(`Could not find CSV match for "${suggestedProduct.name}". Skipping.`);
                    }
                }
            }

            // If API didn't provide usable products for a 'product' query, use fallback
            if (productsToShow.length === 0 && queryType === 'product') {
                console.log("Using fallback search as API provided no usable products or query type was 'product'.");
                const fallbackProducts = fallbackSearch(userQuery);

                if (fallbackProducts.length === 0) {
                    // Only add this message if no products were found via fallback either
                     if (!response.text || !response.text.toLowerCase().includes("couldn't find")) { // Avoid duplicate messages
                        addMessage("I looked through our catalog but couldn't find specific products for that. Perhaps try rephrasing or browse our categories?", 'bot');
                     }
                } else {
                     // Use fallback products
                     productsToShow = fallbackProducts.map(p => ({ // Ensure structure consistency
                        ...p,
                        name: p.name || "Unnamed Product",
                        description: p.description || "Description not available.",
                        price: p.price || "",
                        image: p.image,
                        url: p.url || formatProductUrl(p.name)
                     }));
                     // Add context message if the original response didn't already cover it
                     if (!response.text || !response.text.toLowerCase().includes("relevant")) {
                         addMessage("Based on your query, these might be relevant from our catalog:", 'bot');
                     }
                }
            }

            // Display product cards if any were found (either from API or fallback)
            if (productsToShow.length > 0) {
                const maxCards = 3;
                // Use Promise.all to load cards concurrently (optional, can improve perceived speed)
                await Promise.all(productsToShow.slice(0, maxCards).map(p => addProductCard(p, userQuery)));
            }
        }


        // --- UI Functions ---
        function addMessage(text, sender) {
            const div = document.createElement('div');
            div.className = sender === 'user' ? 'user-message' : 'bot-message';
            // Sanitize again right before insertion for maximum safety, especially for bot messages
            div.innerHTML = DOMPurify.sanitize(text, { USE_PROFILES: { html: true } });
            chatArea.appendChild(div);

            // Animate the message appearance
            anime({
                targets: div,
                translateY: sender === 'user' ? [10, 0] : [10, 0], // Slight upward movement
                opacity: [0, 1],
                duration: 400,
                easing: 'easeOutQuad'
            });

            scrollToBottom();
        }


        function showTypingIndicator() {
            hideTypingIndicator(); // Ensure no duplicate indicators
            const div = document.createElement('div');
            div.id = 'typing-indicator';
            div.className = 'bot-message'; // Style like a bot message
            div.innerHTML = '<span>Thinking</span><span class="typing-dots">.</span>';
            chatArea.appendChild(div);
            scrollToBottom();

            // Animate the dots
            let dotCount = 1;
            const intervalId = setInterval(() => {
                const dotsSpan = div.querySelector('.typing-dots');
                if (dotsSpan) { // Check if element still exists
                    dotCount = (dotCount % 3) + 1;
                    dotsSpan.textContent = '.'.repeat(dotCount);
                } else {
                    clearInterval(intervalId); // Stop if element is gone
                }
            }, 400);
            div.dataset.intervalId = intervalId.toString(); // Store interval ID
        }


        function hideTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                const intervalId = indicator.dataset.intervalId;
                if (intervalId) {
                    clearInterval(parseInt(intervalId, 10)); // Ensure base 10 parsing
                }
                indicator.remove();
            }
        }

        function displayError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message'; // Use specific class for styling errors
            // Sanitize the error message itself before displaying
            errorDiv.innerHTML = DOMPurify.sanitize(`
                <i class="fas fa-exclamation-circle mr-2"></i> ${message}
                <button class="retry-btn mt-2 text-pink-600 underline" aria-label="Retry last message">Try Again</button>
            `);

            // Add event listener to the retry button
            const retryBtn = errorDiv.querySelector('.retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', () => {
                    // Find the last user message in history to retry
                    const lastUserMessage = conversationHistory.filter(m => m.role === 'user').pop();
                    if (lastUserMessage && lastUserMessage.parts[0].text) {
                        chatInput.value = lastUserMessage.parts[0].text; // Put message back in input
                        updateSendButtonState();
                        sendMessage(); // Resend the message
                    } else {
                         addMessage("Could not retrieve the last message to retry.", 'bot');
                    }
                    errorDiv.remove(); // Remove the error message after clicking retry
                });
            }

            chatArea.appendChild(errorDiv);
            scrollToBottom();
        }


        // FIX: Updated addProductCard function (replaces the old one)
        async function addProductCard(p, queryContext) {
            const card = document.createElement('a');
            card.href = p.url || formatProductUrl(p.name); // Use generated URL if needed
            card.target = '_blank';
            card.rel = 'noopener noreferrer';
            card.className = 'product-card animate-fade-in'; // Add fade-in animation
            card.addEventListener('click', () => {
                if (typeof gtag === 'function') {
                    gtag('event', 'product_click', { event_category: 'Chatbot', event_label: p.name || 'Unknown Product' });
                }
            });

            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-loading'; // Container holds spinner or placeholder
            const spinner = document.createElement('div');
            spinner.className = 'spinner';
            imageContainer.appendChild(spinner);
            card.appendChild(imageContainer); // Add container with spinner first

            const img = document.createElement('img');
            img.alt = p.name || "Product Image";
            img.className = 'product-image'; // Base class
            img.style.display = 'none'; // Hide until loaded successfully

            // Define potential image sources in order of preference
            const imageSources = [
                p.image, // Primary image from data
                getBackupImage(p.name || queryContext), // Category-based backup
                backupImages.default // Absolute default placeholder
            ].filter(url => url && typeof url === 'string' && url.trim() !== ''); // Filter out invalid/empty URLs

            let currentAttempt = 0;

            const tryLoadNextImage = () => {
                // Stop if we've run out of sources
                if (currentAttempt >= imageSources.length) {
                    console.warn(`Failed to load any image for product: ${p.name || 'Unknown'}`);
                    // Display the placeholder image within the container
                    imageContainer.innerHTML = `
                        <div class="image-placeholder">
                            <span>Image Not Available</span>
                        </div>`;
                    // Ensure the container is still part of the card
                    if (!card.contains(imageContainer)) {
                        // This might happen if the structure changes unexpectedly
                        // Find the infoDiv and insert before it, or just append if infoDiv isn't there yet
                        const infoDiv = card.querySelector('.product-info');
                        if (infoDiv) {
                            card.insertBefore(imageContainer, infoDiv);
                        } else {
                            card.appendChild(imageContainer);
                        }
                    }
                    return; // Exit the loading attempts
                }

                const url = imageSources[currentAttempt];
                console.log(`Attempt ${currentAttempt + 1} for ${p.name || 'Unknown'}: Trying URL ${url}`);

                // Clear previous listeners to avoid conflicts
                img.onload = null;
                img.onerror = null;

                // Set up listeners for THIS attempt
                img.onload = () => {
                    console.log(`Image loaded successfully: ${img.src}`);
                    img.style.display = 'block'; // Make image visible
                    // Replace the loading container with the loaded image
                    if (imageContainer.parentNode) {
                        imageContainer.replaceWith(img);
                    }
                    // Add lazyloaded class if using lazysizes or similar logic elsewhere
                    // img.classList.add('lazyloaded');
                };

                img.onerror = () => {
                    console.warn(`Attempt ${currentAttempt + 1} for ${p.name || 'Unknown'}: URL ${url} failed to load (onerror).`);
                    currentAttempt++;
                    // Don't keep the failed img element attached if it's not needed
                    // The container remains until replaced or placeholder shown
                    tryLoadNextImage(); // Try the next source
                };

                // Set the src to trigger loading for THIS attempt
                img.src = url;
            };

            // Start the first attempt
            tryLoadNextImage();

            // --- Add Product Info ---
            const MAX_TITLE_LENGTH = 50;
            const MAX_DESC_LENGTH = 100;

            // Ensure name and description are strings before processing
            const productName = typeof p.name === 'string' ? p.name : "Unnamed Product";
            const productDesc = typeof p.description === 'string' ? p.description : "Click for details.";

            const truncatedName = productName.length > MAX_TITLE_LENGTH
                ? productName.substring(0, MAX_TITLE_LENGTH) + '...'
                : productName;
            const truncatedDesc = productDesc.length > MAX_DESC_LENGTH
                ? productDesc.substring(0, MAX_DESC_LENGTH) + '...'
                : productDesc;

            const infoDiv = document.createElement('div');
            infoDiv.className = 'product-info';
            // Sanitize content before setting innerHTML
            infoDiv.innerHTML = DOMPurify.sanitize(`
                <div class="product-name" title="${productName}">${truncatedName}</div>
                <div class="product-description">${truncatedDesc}</div>
                <div class="product-price">${p.price ? DOMPurify.sanitize(p.price) : ""}</div>
            `, { USE_PROFILES: { html: true } }); // Allow basic HTML like line breaks if needed, but sanitize

            card.appendChild(infoDiv); // Append info after image container/image
            chatArea.appendChild(card); // Add the complete card to the chat
            scrollToBottom(); // Ensure view scrolls down
        }


        function scrollToBottom() {
            requestAnimationFrame(() => {
                chatArea.scrollTop = chatArea.scrollHeight;
            });
        }

        function updateUserProfile(botResponseText) {
            if (typeof botResponseText !== 'string') return; // Basic validation

            const textLower = botResponseText.toLowerCase();
            let updated = false;
            const newProfile = { ...userProfile }; // Create a copy to modify

            // Example logic (can be expanded)
            if (textLower.includes('dry skin') && newProfile.skinType !== 'Dry') {
                newProfile.skinType = 'Dry';
                updated = true;
            } else if (textLower.includes('oily skin') && newProfile.skinType !== 'Oily') {
                newProfile.skinType = 'Oily';
                updated = true;
            } else if (textLower.includes('combination skin') && newProfile.skinType !== 'Combination') {
                 newProfile.skinType = 'Combination';
                 updated = true;
            } else if (textLower.includes('sensitive skin') && newProfile.skinType !== 'Sensitive') {
                 newProfile.skinType = 'Sensitive';
                 updated = true;
            }


            // Example concern tracking
            if (textLower.includes('acne') && !newProfile.concerns.includes('Acne')) {
                newProfile.concerns.push('Acne');
                updated = true;
            }
             if (textLower.includes('wrinkles') || textLower.includes('fine lines') && !newProfile.concerns.includes('Aging')) {
                newProfile.concerns.push('Aging');
                updated = true;
            }
             if (textLower.includes('dullness') && !newProfile.concerns.includes('Dullness')) {
                newProfile.concerns.push('Dullness');
                updated = true;
            }


            // If any changes were made, update the global profile object
            if (updated) {
                Object.assign(userProfile, newProfile); // Update the original object
                console.log(`User profile updated - Skin Type: ${userProfile.skinType || 'N/A'}, Concerns: ${userProfile.concerns.length > 0 ? userProfile.concerns.join(', ') : 'None'}`);
            }
        }

    </script>
</body>
</html>
