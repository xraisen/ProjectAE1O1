<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Planet Beauty AI Chatbot - Find personalized beauty products with our interactive assistant.">
    <link rel="icon" href="https://via.placeholder.com/16x16/E91e63/FFFFFF?text=PB" type="image/png">
    <title>Planet Beauty AI Chatbot</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DLVD913P7M"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-DLVD913P7M'); // Replace with your GA ID
    </script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f8f9fa;
            margin: 0;
            overflow-x: hidden;
        }
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #e91e63;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        #preloader .percentage {
            font-size: 1.5rem;
            font-weight: 500;
            color: #e91e63;
        }
        .chat-container {
            max-width: 900px;
            margin: 0 auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 12px;
            background: white;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 140px);
            max-height: 800px;
        }
        .chat-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
            will-change: scroll-position;
        }
        .user-message {
            background: #e91e63;
            color: white;
            padding: .75rem 1rem;
            border-radius: 15px 15px 0 15px;
            max-width: 80%;
            margin-left: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .bot-message {
            background: #f0f0f0;
            color: #333;
            padding: .75rem 1rem;
            border-radius: 15px 15px 15px 0;
            max-width: 80%;
            margin-right: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .product-card {
            display: block;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            margin: 1rem 0;
            text-decoration: none;
            color: inherit;
            background: white;
            max-width: 80%;
            margin-right: auto;
        }
        .product-card:hover {
            transform: scale(1.03);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .product-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }
        .lazyload, .lazyloading {
            opacity: 0;
            transition: opacity 0.3s;
        }
        .lazyloaded {
            opacity: 1;
        }
        .image-loading {
            position: relative;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f5f5f5;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(233, 30, 99, 0.2);
            border-top-color: #e91e63;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .image-placeholder {
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #eee;
            color: #666;
            font-size: 0.9em;
            text-align: center;
        }
        .product-info {
            padding: 1rem;
        }
        .product-name {
            font-weight: 600;
            margin-bottom: .25rem;
        }
        .product-description {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: .5rem;
        }
        .product-price {
            font-weight: 500;
            color: #e91e63;
        }
        .examples-container {
            display: flex;
            flex-wrap: wrap;
            gap: .5rem;
            margin-bottom: 1rem;
            max-width: 80%;
        }
        .example-chip {
            padding: .5rem 1rem;
            background: #f0f0f0;
            border: 1px solid #e0e0e0;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s, box-shadow 0.2s;
            font-size: 0.9rem;
        }
        .example-chip:hover {
            background: #e91e63;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .example-chip:focus {
            outline: 2px solid #e91e63;
            outline-offset: 2px;
        }
        .input-area {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #eee;
            background: #fff;
        }
        .input-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        input[type=text] {
            flex: 1;
            padding: .75rem 1rem;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            transition: border-color 0.3s;
        }
        input[type=text]:focus {
            border-color: #e91e63;
        }
        input[type=text]:disabled {
            background-color: #f5f5f5;
        }
        .send-btn {
            background: #e91e63;
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            flex-shrink: 0;
        }
        .send-btn:hover {
            background: #d81b60;
            transform: scale(1.05);
        }
        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: .75rem 1rem;
            border-radius: 15px;
            margin-bottom: 1rem;
            max-width: 80%;
            margin-right: auto;
            border: 1px solid #f4c7c7;
        }
        .retry-btn {
            background: none;
            border: none;
            color: #e91e63;
            text-decoration: underline;
            cursor: pointer;
        }
        footer {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 0.5rem 1rem;
            color: #6c757d;
            font-size: 0.875rem;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        footer a {
            color: #e91e63;
            text-decoration: none;
            margin-left: 0.25rem;
        }
        footer a:hover {
            text-decoration: underline;
        }
        #typing-indicator .typing-dots {
            display: inline-block;
            width: 1.5em;
            text-align: left;
            vertical-align: bottom;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @media (max-width: 640px) {
            body {
                padding: 0;
            }
            .chat-container {
                border-radius: 0;
                max-width: 100%;
                height: 100vh;
                max-height: none;
                margin: 0;
            }
            .chat-area {
                padding: 1rem;
            }
            .user-message, .bot-message, .product-card, .examples-container, .error-message {
                max-width: 90%;
            }
            .input-area {
                padding: 0.75rem;
            }
            input[type=text] {
                padding: 0.6rem 0.9rem;
            }
            .send-btn {
                width: 40px;
                height: 40px;
            }
            footer {
                font-size: 0.8rem;
                padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
            }
            #preloader .percentage {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <div id="preloader">
        <div class="spinner"></div>
        <div class="percentage">0%</div>
    </div>
    <header class="text-center py-6 px-4 flex-shrink-0 bg-gradient-to-r from-pink-600 to-purple-700 text-white shadow-md animate-fade-in">
        <h1 class="text-3xl sm:text-4xl font-bold">Planet Beauty</h1>
        <p class="text-lg sm:text-xl">Your AI Beauty Assistant ✨</p>
    </header>

    <main class="chat-container flex-grow animate-fade-in">
        <div id="chat-area" class="chat-area">
            <div class="bot-message">Hi there! Welcome to Planet Beauty's AI Assistant. ✨ How can I help you find the perfect products today?</div>
            <div id="examples-container" class="examples-container"></div>
        </div>

        <div class="input-area">
            <div class="input-row">
                <input id="chat-input" type="text" placeholder="Ask about beauty products..." autocomplete="off" aria-label="Type your beauty product question">
                <button id="send-btn" class="send-btn" disabled aria-label="Send message"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </main>

    <footer>
        <span>Developed with ❤️ by</span>
        <a href="https://www.linkedin.com/in/joseespinosa" target="_blank" rel="noopener noreferrer">Jose Espinosa</a>
    </footer>

    <script>
        // --- Configuration ---
        const GEMINI_API_KEY = 'AIzaSyCpI-eNfqWk_ZiK2qHOj_tD2NzeAJ_U398'; // Replace with your Gemini API key
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`; // Updated model
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzzp5mD6Nu3RZmYvjzDFXvCNC5MhJyfNMvs_MJDYLqZ8Uad1BJE-cO1WWg7BpoYO62_/exec'; // Replace with your deployed Web App URL
        const API_TIMEOUT = 20000; // Increased timeout slightly
        const IMAGE_TIMEOUT = 15000;
        const PRELOADER_MIN_DURATION = 1000;
        const PERCENTAGE_ANIMATION_DURATION = 2000;
        const PLANET_BEAUTY_DOMAIN = 'https://www.planetbeauty.com'; // Define domain constant

        // --- Fallback Questions ---
        const FALLBACK_QUESTIONS = [
            "What products are best for sensitive skin at Planet Beauty?",
            "Can you recommend a conditioner for curly hair from Planet Beauty?",
            "What's a good cleanser for combination skin available at Planet Beauty?",
            "Which makeup is ideal for a natural look from Planet Beauty?"
        ];

        // --- State ---
        const userProfile = { skinType: null, skinTone: null, concerns: [] };
        let conversationHistory = [];
        const MAX_HISTORY = 10; // Retain 5 user-model pairs
        const imageCache = JSON.parse(localStorage.getItem('imageCache')) || {};
        let products = []; // Holds the catalog fetched from the Web App
        let productCategories = {};
        let lastQueryContext = { productType: null, preferences: [] }; // Track user intent
        const backupImages = {
            default: 'https://via.placeholder.com/600x400/E91e63/FFFFFF?text=Planet+Beauty',
        };

        // --- Category Keywords ---
        const categoryKeywords = {
            acne: ['acne', 'blemish', 'pimple', 'breakout', 'clear skin', 'oily'],
            moisturizer: ['moisturizer', 'hydrating', 'dry skin', 'hydration', 'cream', 'lotion'],
            shampoo: ['shampoo', 'hair wash', 'clean hair'],
            conditioner: ['conditioner', 'soften hair', 'detangle'],
            hairmask: ['hair mask', 'treatment', 'damaged hair', 'repair hair'],
            foundation: ['foundation', 'makeup base', 'cover', 'complexion', 'tone'],
            serum: ['serum', 'treatment', 'concentrate', 'anti-aging', 'brightening'],
            cleanser: ['cleanser', 'face wash', 'wash'],
            exfoliant: ['exfoliant', 'scrub', 'peel', 'smooth skin'],
            styling: ['styling', 'hairspray', 'texture', 'volume', 'hold', 'gel', 'mousse'],
            // Ensure 'skincare' covers terms relevant to alternatives for niche requests
            skincare: ['skincare', 'face care', 'complexion', 'skin health', 'red light', 'therapy', 'anti-aging', 'brightening', 'firming'],
            haircare: ['haircare', 'hair product', 'mane'],
            sunscreen: ['sunscreen', 'spf', 'uv', 'protection']
        };

        // --- DOM Elements ---
        const chatArea = document.getElementById('chat-area');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const preloader = document.getElementById('preloader');
        const examplesContainer = document.getElementById('examples-container');

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            let percentage = 0;
            const percentageElement = preloader.querySelector('.percentage');
            const animatePercentage = () => {
                return new Promise(resolve => {
                    anime({
                        targets: { value: percentage },
                        value: 90,
                        duration: PERCENTAGE_ANIMATION_DURATION,
                        easing: 'easeOutQuad',
                        update: (anim) => {
                            percentage = Math.round(anim.animatables[0].target.value);
                            percentageElement.textContent = `${percentage}%`;
                        },
                        complete: () => resolve()
                    });
                });
            };

            const minDurationPromise = new Promise(resolve => setTimeout(resolve, PRELOADER_MIN_DURATION));
            const animationPromise = animatePercentage();
            try {
                products = await fetchProducts(); // Fetch and validate products
                categorizeProducts();
                await generateSuggestedQuestions();
                await Promise.all([minDurationPromise, animationPromise]);
                await anime({
                    targets: { value: percentage },
                    value: 100,
                    duration: 300,
                    easing: 'easeOutQuad',
                    update: (anim) => {
                        percentageElement.textContent = `${Math.round(anim.animatables[0].target.value)}%`;
                    }
                }).finished;
                preloader.style.opacity = '0';
                setTimeout(() => preloader.remove(), 500);
            } catch (error) {
                console.error('Initialization error:', error);
                percentageElement.textContent = 'Error';
                percentageElement.style.color = '#c62828';
                await Promise.all([minDurationPromise, animationPromise]); // Wait even on error
                preloader.style.opacity = '0';
                setTimeout(() => preloader.remove(), 500);
                addMessage("Sorry, I couldn't load the Planet Beauty product catalog. Please try refreshing the page or come back later.", 'bot');
            }

            anime({
                targets: 'header',
                translateY: [-20, 0],
                opacity: [0, 1],
                duration: 800,
                easing: 'easeOutQuad'
            });

            chatInput.addEventListener('keyup', handleInputKeyup);
            chatInput.addEventListener('input', handleInputChange);
            sendBtn.addEventListener('click', () => {
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            });
            chatInput.focus();
            updateSendButtonState();
        });

        // --- Fetch Products (with Strict URL Validation) ---
        async function fetchProducts() {
            try {
                const res = await axios.get(WEB_APP_URL, { timeout: API_TIMEOUT });
                if (res.data && Array.isArray(res.data.products)) {
                    const validatedProducts = res.data.products.map((p, index) => {
                        let productUrl = p.url;
                        // Validate URL: Must be within planetbeauty.com
                        if (productUrl && typeof productUrl === 'string') {
                            try {
                                const parsedUrl = new URL(productUrl);
                                if (!parsedUrl.hostname.endsWith('planetbeauty.com')) {
                                    console.warn(`Product ${p.name || index} has external URL (${productUrl}). Replacing with formatted URL.`);
                                    productUrl = formatProductUrl(p.name); // Generate safe URL
                                } else {
                                    // Ensure HTTPS
                                    productUrl = productUrl.replace(/^http:/, 'https:');
                                }
                            } catch (e) {
                                console.warn(`Product ${p.name || index} has invalid URL (${productUrl}). Replacing with formatted URL.`);
                                productUrl = formatProductUrl(p.name); // Generate safe URL on parse error
                            }
                        } else {
                            // If no URL provided, generate one
                            productUrl = formatProductUrl(p.name);
                        }

                        // Ensure image URL uses HTTPS if possible
                        let imageUrl = p.image;
                        if (imageUrl && typeof imageUrl === 'string' && imageUrl.startsWith('http://')) {
                            imageUrl = imageUrl.replace('http://', 'https://');
                        }

                        return {
                            ...p,
                            id: p.id || `p${index + 1}`, // Ensure unique ID
                            name: p.name || "Unnamed Product", // Provide default name
                            description: p.description || "No description available.", // Default description
                            price: p.price || "", // Default price
                            image: imageUrl,
                            url: productUrl // Use the validated/generated URL
                        };
                    });
                    console.log("Products loaded and validated from Web App:", validatedProducts.length);
                    if (validatedProducts.length === 0) {
                         console.warn("Warning: Fetched product list is empty.");
                    }
                    return validatedProducts;
                } else if (res.data && res.data.error) {
                    throw new Error(`Web App Error: ${res.data.error}`);
                } else {
                    throw new Error("Invalid data format received from Web App (expected { products: [...] }).");
                }
            } catch (error) {
                console.error('Failed to fetch or validate products:', error);
                // Don't throw here, allow the app to load but show an error message later
                return []; // Return empty array on failure
            }
        }

        // --- Categorize Products ---
        function categorizeProducts() {
            if (!products || products.length === 0) {
                console.warn("Cannot categorize products: Product list is empty.");
                return;
            }
            products.forEach(product => {
                product.categories = [];
                const nameLower = (product.name || "").toLowerCase();
                const descLower = (product.description || "").toLowerCase();
                for (const [category, keywords] of Object.entries(categoryKeywords)) {
                    if (keywords.some(keyword => nameLower.includes(keyword) || descLower.includes(keyword))) {
                        product.categories.push(category);
                    }
                }
            });
            // Create map of categories to products
            productCategories = Object.fromEntries(
                Object.keys(categoryKeywords).map(category => [
                    category,
                    products.filter(p => p.categories && p.categories.includes(category))
                ])
            );
            // Populate backup images per category
            for (const category of Object.keys(productCategories)) {
                backupImages[category] = productCategories[category]
                    .map(p => p.image)
                    .filter(img => img && typeof img === 'string');
            }
        }

        // --- Suggested Questions ---
        async function generateSuggestedQuestions() {
            // Only generate if products were loaded successfully
            if (products.length === 0) {
                 displaySuggestedQuestions(FALLBACK_QUESTIONS); // Use fallbacks if no products
                 return;
            }
            try {
                const questions = await fetchSuggestedQuestions();
                displaySuggestedQuestions(questions);
            } catch (error) {
                console.error('Failed to generate suggested questions:', error);
                displaySuggestedQuestions(FALLBACK_QUESTIONS); // Use fallbacks on error
            }
        }

        async function fetchSuggestedQuestions() {
            // Use a simpler prompt focusing on available categories if possible
            const availableCategories = Object.keys(productCategories).filter(cat => productCategories[cat].length > 0);
            const focusCategories = availableCategories.length > 3 ? availableCategories.slice(0, 3).join(', ') : 'skincare, haircare, makeup';

            const prompt = {
                contents: [{
                    role: 'user',
                    parts: [{
                        text: `Generate 4 concise, varied, and helpful beauty-related questions for a chatbot exclusive to Planet Beauty (${PLANET_BEAUTY_DOMAIN}). Questions MUST focus on products likely available in the Planet Beauty catalog (e.g., focus on ${focusCategories}). Address common user needs like recommendations for specific skin types, hair concerns, or makeup looks. Ensure questions explicitly mention Planet Beauty. Return the response ONLY as a valid JSON array of 4 strings.

                        Example valid JSON output:
                        ["What's the best moisturizer for oily skin at Planet Beauty?", "Can you recommend a shampoo for dry hair from Planet Beauty?", "What foundation suits sensitive skin at Planet Beauty?", "Which serum helps with fine lines available at Planet Beauty?"]`
                    }]
                }],
                generationConfig: {
                    temperature: 0.8, // Slightly higher temp for variety
                    topP: 0.95,
                    topK: 40,
                    maxOutputTokens: 256,
                    responseMimeType: 'application/json'
                },
                safetySettings: [ // Standard safety settings
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                ]
            };

            const res = await axios.post(GEMINI_API_URL, prompt, {
                headers: { 'Content-Type': 'application/json' },
                timeout: API_TIMEOUT
            });

            if (res.data?.candidates?.[0]?.content?.parts?.[0]?.text) {
                const responseText = res.data.candidates[0].content.parts[0].text;
                try {
                    // Attempt to clean potential markdown/extra chars before parsing
                    const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                    const questions = JSON.parse(cleanedText);
                    if (Array.isArray(questions) && questions.length >= 4 && questions.every(q => typeof q === 'string')) {
                        return questions.slice(0, 4); // Return exactly 4 valid questions
                    } else {
                         console.warn("Parsed questions format invalid:", questions);
                    }
                } catch (parseError) {
                    console.error('JSON Parse Error for suggested questions:', parseError, 'Raw text:', responseText);
                }
            }
            // If API fails or returns invalid format, throw error to trigger fallback
            throw new Error('Failed to fetch valid suggested questions from API.');
        }

        function displaySuggestedQuestions(questions) {
            examplesContainer.innerHTML = ''; // Clear previous suggestions
            if (!Array.isArray(questions)) {
                console.error("Cannot display suggestions: input is not an array.", questions);
                questions = FALLBACK_QUESTIONS; // Default to fallbacks
            }
            questions.forEach((question, index) => {
                if (typeof question !== 'string' || !question.trim()) {
                    console.warn(`Skipping invalid suggestion at index ${index}:`, question);
                    return; // Skip empty or non-string suggestions
                }
                const chip = document.createElement('div');
                chip.className = 'example-chip';
                chip.setAttribute('data-q', question);
                chip.setAttribute('role', 'button');
                chip.tabIndex = 0; // Make it focusable
                chip.setAttribute('aria-label', `Ask: ${question}`);
                chip.textContent = question;
                chip.addEventListener('click', handleExampleClick);
                chip.addEventListener('keypress', (e) => { // Allow activation with Enter/Space
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault(); // Prevent scrolling on space
                        handleExampleClick(e);
                    }
                });
                examplesContainer.appendChild(chip);
            });

            // Animate the chips appearing
            anime({
                targets: '.example-chip',
                translateX: [-20, 0],
                opacity: [0, 1],
                delay: anime.stagger(100),
                duration: 600,
                easing: 'easeOutQuad'
            });
        }

        // --- Utilities ---
        function formatProductUrl(productName) {
            const baseUrl = `${PLANET_BEAUTY_DOMAIN}/products/`;
            if (!productName || typeof productName !== 'string') {
                // Fallback to a general search or homepage if name is invalid
                return `${PLANET_BEAUTY_DOMAIN}/search?q=product`;
            }
            // Generate a slug-like path
            const slug = productName.toLowerCase()
                .replace(/[^\w\s-]/g, '') // Remove non-alphanumeric chars except space/hyphen
                .trim()
                .replace(/\s+/g, '-') // Replace spaces with hyphens
                .replace(/-+/g, '-'); // Collapse multiple hyphens
            return baseUrl + slug;
        }

        function getBackupImage(query) {
            const queryLower = (query || "").toLowerCase();
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => queryLower.includes(keyword))) {
                    const imageArray = backupImages[category] || [];
                    if (imageArray.length > 0) {
                        // Return a random image from the category's backups
                        return imageArray[Math.floor(Math.random() * imageArray.length)];
                    }
                }
            }
            // Default backup if no category match
            return backupImages.default;
        }

        // --- Event Handlers ---
        function handleExampleClick(event) {
            const query = event.currentTarget.getAttribute('data-q');
            if (query) {
                chatInput.value = query;
                updateSendButtonState();
                sendMessage(); // Send the message automatically
                if (typeof gtag === 'function') {
                    gtag('event', 'example_chip_click', { event_category: 'Chatbot', event_label: query });
                }
            }
        }

        function handleInputKeyup(event) {
            if (event.key === 'Enter' && !sendBtn.disabled) {
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message_enter', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            }
        }

        function handleInputChange() {
            updateSendButtonState();
        }

        function updateSendButtonState() {
            sendBtn.disabled = chatInput.value.trim() === '';
        }

        // --- Core Functions ---
        async function sendMessage() {
            const rawMessage = chatInput.value.trim();
            if (!rawMessage) return; // Don't send empty messages

            // Sanitize user input before displaying and sending
            const message = DOMPurify.sanitize(rawMessage, { USE_PROFILES: { html: false } }); // Disallow HTML in user messages
            addMessage(message, 'user');

            // Add sanitized message to history for API call
            const userMessageEntry = { role: 'user', parts: [{ text: message }] };
            conversationHistory.push(userMessageEntry);
            // Trim history if it exceeds max length
            if (conversationHistory.length > MAX_HISTORY * 2) { // Keep MAX_HISTORY pairs (user+model)
                 conversationHistory = conversationHistory.slice(-MAX_HISTORY * 2);
            }


            // Update context based on the *sanitized* message
            updateQueryContext(message);

            chatInput.value = ''; // Clear input field
            updateSendButtonState(); // Disable send button
            chatInput.disabled = true; // Disable input during processing
            sendBtn.disabled = true;

            showTypingIndicator();

            try {
                // Check if products loaded, if not, show error and stop
                if (products.length === 0) {
                    throw new Error("Product catalog not available.");
                }
                const response = await callGeminiAPI();
                await processResponse(response, message); // Process the API response
            } catch (error) {
                console.error('Error during message processing:', error);
                hideTypingIndicator();
                let errorMessage = "I encountered an issue processing your request. Please try again.";
                if (error.message.includes('timed out')) {
                    errorMessage = "The request timed out. Please check your connection and try again.";
                } else if (error.message.includes("Product catalog not available")) {
                    errorMessage = "Sorry, I can't search for products right now as the catalog isn't loaded. Please try refreshing the page.";
                } else if (error.message.includes("blocked")) {
                    errorMessage = `Request blocked due to safety settings (${error.message}). Please rephrase your query.`;
                }
                displayError(errorMessage); // Show user-friendly error

                // Attempt fallback search even on API error, if products are loaded
                if (products.length > 0) {
                    const fallbackProducts = fallbackSearch(message);
                    if (fallbackProducts.length > 0) {
                        addMessage("I had trouble with the AI search, but here are some products from our catalog that might match:", 'bot');
                        await Promise.all(fallbackProducts.map(p => addProductCard(p, message)));
                    } else {
                         addMessage("I couldn't find matching products in our catalog even with a fallback search. Could you try rephrasing?", 'bot');
                    }
                }
            } finally {
                // Re-enable input regardless of success or failure
                chatInput.disabled = false;
                updateSendButtonState();
                chatInput.focus(); // Set focus back to input
            }
        }

        async function callGeminiAPI(retry = false) {
            try {
                const prompt = createPrompt(); // Generate the prompt with history and instructions
                const payload = {
                    contents: prompt,
                    generationConfig: {
                        temperature: 0.5, // Slightly lower temp for more focused product results
                        topP: 0.95,
                        topK: 40,
                        maxOutputTokens: 1024,
                        responseMimeType: 'application/json' // Expect JSON response
                    },
                    safetySettings: [ // Standard safety settings
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                    ]
                };

                const res = await axios.post(GEMINI_API_URL, payload, {
                    headers: { 'Content-Type': 'application/json' },
                    timeout: API_TIMEOUT // Use configured timeout
                });

                // Validate response structure
                if (res.data?.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const responseText = res.data.candidates[0].content.parts[0].text;
                    try {
                        // Clean potential markdown before parsing
                        const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                        const parsedResponse = JSON.parse(cleanedText);

                        // Basic validation of the parsed JSON structure
                        if (typeof parsedResponse !== 'object' || parsedResponse === null ||
                            typeof parsedResponse.text !== 'string' ||
                            typeof parsedResponse.query_type !== 'string' ||
                            !Array.isArray(parsedResponse.products)) {
                            console.error('Invalid JSON structure received from API:', parsedResponse);
                            throw new Error('Invalid response structure from API.');
                        }

                        // Add valid model response to history
                        conversationHistory.push({ role: 'model', parts: [{ text: cleanedText }] });
                        return parsedResponse; // Return the valid, parsed response

                    } catch (parseError) {
                        console.error('JSON Parse Error in API response:', parseError, 'Raw text:', responseText);
                        // If parsing fails, treat it as an error but maybe provide a generic text response
                         return { text: "I received a response, but couldn't fully understand it. Let me try to find products based on your query.", query_type: 'other', products: [] };
                    }
                } else if (res.data?.promptFeedback?.blockReason) {
                    // Handle blocked requests explicitly
                    console.error(`API request blocked: ${res.data.promptFeedback.blockReason}`);
                    throw new Error(`Request blocked: ${res.data.promptFeedback.blockReason}`);
                } else {
                    // Handle other unexpected response formats
                    console.error('Unexpected API response format:', res.data);
                    throw new Error('Unexpected response format from API.');
                }
            } catch (error) {
                // Handle network errors or timeouts, potentially retry once for timeouts
                if (!retry && error.code === 'ECONNABORTED' || (error.response && error.response.status === 408)) {
                    console.warn('API call timed out, retrying once...');
                    return await callGeminiAPI(true); // Retry once
                }
                 console.error('Error calling Gemini API:', error);
                // Re-throw other errors to be caught by sendMessage
                throw error;
            }
        }

        function createPrompt() {
            // Summarize recent user queries for context, ensuring parts[0].text exists
             const recentQueries = conversationHistory
                .filter(entry => entry.role === 'user' && entry.parts?.[0]?.text)
                .slice(-3) // Get last 3 user messages
                .map(entry => entry.parts[0].text)
                .join('; ');
            const contextSummary = recentQueries ? `Recent user queries for context: ${recentQueries}` : 'This is the start of the conversation.';

            // System instruction defining the chatbot's role and constraints
            const systemInstruction = {
                role: 'user', // System instructions are often passed in the 'user' role initially
                parts: [{
                    text: `You are a friendly and helpful AI assistant for Planet Beauty (${PLANET_BEAUTY_DOMAIN}). Your primary goal is to assist users with beauty product queries using ONLY products from the Planet Beauty catalog (which is known to you implicitly via the system, you don't see the raw data). Engage in natural, helpful conversation.

**VERY IMPORTANT RULES:**
1.  **Strictly Planet Beauty:** ONLY recommend products available at Planet Beauty. ABSOLUTELY DO NOT suggest products or provide information/links for websites outside of ${PLANET_BEAUTY_DOMAIN}.
2.  **Catalog Focus:** Base recommendations on typical beauty products (skincare, haircare, makeup).
3.  **JSON Output:** ALWAYS respond with a valid JSON object containing three keys: "text" (your conversational reply, max 150 words), "query_type" (string: "greeting", "product", "other"), and "products" (array of product objects OR an empty array []).
4.  **Product Object Format:** When recommending products, the "products" array must contain objects with ONLY a "name" key, matching a Planet Beauty product name exactly. Example: \`{"name": "Specific Product Name Here"}\`
5.  **Handling Not Found:** If a user asks for a specific product type (e.g., "red light therapy device") that is NOT typically sold by Planet Beauty or likely not in the catalog:
    *   Set "query_type": "product".
    *   In the "text", clearly state it's not available *at Planet Beauty*.
    *   Suggest 1-2 relevant *alternative* product types available at Planet Beauty (e.g., "anti-aging serums" or "brightening treatments").
    *   Include the names of 1-2 specific alternative products from the catalog in the "products" array. Example: \`{"products": [{"name": "Alternative Serum A"}, {"name": "Alternative Cream B"}]}\`
    *   If no suitable alternatives exist, return an empty "products" array.
6.  **Query Types:**
    *   "greeting": For simple hellos, how are you, etc. Respond warmly, "products": [].
    *   "product": For requests about specific products, categories, concerns (e.g., "dry skin moisturizer", "shampoo for colored hair", "red light therapy"). Provide text response and matching "products" array (or alternatives if not found).
    *   "other": For thanks, goodbyes, questions about store hours (which you don't know - politely state that), or unclear queries. Respond appropriately, "products": [].
7.  **Context:** Use the conversation history (${contextSummary}) to understand follow-up questions (e.g., if user asks for "cheapest" after a product recommendation, refine the previous suggestion if possible).

**Example Scenarios:**

*   User: Hi there
    Assistant JSON: \`{"text": "Hello! Welcome to Planet Beauty's assistant. How can I help you find the perfect beauty product today?", "query_type": "greeting", "products": []}\`
*   User: I need a good moisturizer for very dry skin
    Assistant JSON: \`{"text": "Hydration is key for very dry skin! Here are a couple of great options from Planet Beauty:", "query_type": "product", "products": [{"name": "Dermalogica Intensive Moisture Balance"}, {"name": "SkinCeuticals Triple Lipid Restore 2:4:2"}]}\`
*   User: which one is cheaper? (Follow-up)
    Assistant JSON: \`{"text": "Let me check the pricing... The Dermalogica Intensive Moisture Balance is generally more budget-friendly.", "query_type": "product", "products": [{"name": "Dermalogica Intensive Moisture Balance"}]}\` (Assumes system can check price or makes educated guess)
*   User: Do you sell red light therapy masks?
    Assistant JSON: \`{"text": "Planet Beauty doesn't currently carry red light therapy masks. However, if you're interested in anti-aging or skin rejuvenation, we have excellent serums and treatments. Would you like to explore those?", "query_type": "product", "products": [{"name": "Peter Thomas Roth Peptide 21 Wrinkle Resist Serum"}, {"name": " Murad Retinol Youth Renewal Night Cream"}]}\`
*   User: Thanks!
    Assistant JSON: \`{"text": "You're very welcome! Let me know if anything else comes up.", "query_type": "other", "products": []}\`

Now, respond to the latest user message based on these rules and the conversation history.`
                }]
            };

            // Filter history to ensure valid structure before sending
            const validHistory = conversationHistory.filter(entry =>
                entry.role && (entry.role === 'user' || entry.role === 'model') &&
                entry.parts && Array.isArray(entry.parts) && entry.parts[0] && typeof entry.parts[0].text === 'string'
            );

            // Combine system instruction with valid conversation history
            return [systemInstruction, ...validHistory];
        }


        function fallbackSearch(query, context = lastQueryContext) {
            const queryLower = (query || "").toLowerCase();
            if (!queryLower || products.length === 0) return []; // Need query and products

            // Basic keyword extraction (improved slightly)
            const stopWords = new Set(['the', 'a', 'an', 'is', 'for', 'what', 'can', 'you', 'recommend', 'find', 'me', 'i', 'need', 'with', 'of', 'my', 'skin', 'hair', 'product', 'products', 'at', 'from', 'planet', 'beauty']);
            const keywords = queryLower.split(/[\s,.;!?-]+/) // Split by common delimiters
                .filter(word => word.length > 2 && !stopWords.has(word));

            let matchedProducts = [];
            const isRefinement = keywords.some(k => ['cheapest', 'cheaper', 'affordable', 'lowest', 'price', 'cost'].includes(k));

            // --- Refinement Handling (e.g., "cheapest") ---
            if (isRefinement && context.productType) {
                console.log(`Fallback: Refining search for cheapest '${context.productType}'`);
                matchedProducts = products.filter(p =>
                    p.categories && p.categories.includes(context.productType) &&
                    p.price && typeof p.price === 'string' && p.price.includes('$') // Ensure price exists
                ).sort((a, b) => {
                    // Robust price parsing
                    const priceA = parseFloat(a.price.replace(/[^0-9.]/g, '')) || Infinity;
                    const priceB = parseFloat(b.price.replace(/[^0-9.]/g, '')) || Infinity;
                    return priceA - priceB;
                });
                return matchedProducts.slice(0, 3); // Return top 3 cheapest
            }

            // --- Standard Fallback Search ---
            // 1. Category Matching: Find products in categories mentioned in the query
            let categoryMatches = new Set();
            let matchedCategory = null;
            for (const [category, catKeywords] of Object.entries(categoryKeywords)) {
                if (catKeywords.some(kw => queryLower.includes(kw))) {
                    matchedCategory = category; // Store the primary matched category
                    const categoryProducts = productCategories[category] || [];
                    categoryProducts.forEach(product => categoryMatches.add(product));
                    // Prioritize the first strong category match for relevance
                    break;
                }
            }
             // If no strong category match, check keywords against all categories
             if (!matchedCategory) {
                 for (const [category, catKeywords] of Object.entries(categoryKeywords)) {
                     if (keywords.some(kw => catKeywords.includes(kw))) {
                         const categoryProducts = productCategories[category] || [];
                         categoryProducts.forEach(product => categoryMatches.add(product));
                     }
                 }
             }


            // 2. Keyword Scoring: Score all products based on keyword presence in name/desc
            const scoredProducts = products.map(product => {
                let score = 0;
                const nameLower = (product.name || "").toLowerCase();
                const descLower = (product.description || "").toLowerCase();

                // Boost score if product is in a matched category
                if (categoryMatches.has(product)) score += 5;

                // Score based on keyword matches
                keywords.forEach(term => {
                    if (nameLower.includes(term)) score += 3; // Higher score for name match
                    if (descLower.includes(term)) score += 1; // Lower score for description match
                });
                 // Bonus for exact phrase match in name
                 if (nameLower.includes(queryLower)) score += 10;


                return { product, score };
            });

            // 3. Combine and Rank: Filter out zero-score, sort by score, remove duplicates
            const relevantProducts = scoredProducts
                .filter(item => item.score > 0) // Only include products with a score
                .sort((a, b) => b.score - a.score) // Sort descending by score
                .map(item => item.product);

            // Use a Map to ensure uniqueness based on ID or Name
            const combinedResults = new Map();
            // Add category matches first (they are generally more relevant)
            Array.from(categoryMatches).forEach(p => combinedResults.set(p.id || p.name, p));
            // Add other relevant products, avoiding duplicates
            relevantProducts.forEach(p => {
                if (!combinedResults.has(p.id || p.name)) {
                    combinedResults.set(p.id || p.name, p);
                }
            });

            console.log(`Fallback: Found ${combinedResults.size} potential matches for "${query}"`);
            // Return top 3 results from the combined list
            return Array.from(combinedResults.values()).slice(0, 3);
        }


        async function processResponse(response, userQuery) {
            hideTypingIndicator();

            if (!response || typeof response !== 'object') {
                console.error("Invalid response object received:", response);
                addMessage("Sorry, I received an unexpected response format. Please try rephrasing.", 'bot');
                return;
            }

            // Sanitize and display the bot's text response
            if (response.text) {
                addMessage(DOMPurify.sanitize(response.text, { USE_PROFILES: { html: true } }), 'bot');
                updateUserProfile(response.text); // Update profile based on bot's understanding
            } else {
                // Provide a generic response if text is missing but products might be relevant
                addMessage("Let me see what I can find for you in the Planet Beauty catalog...", 'bot');
            }

            const queryType = response.query_type || 'other';
            let productsToShow = []; // Products to be displayed as cards

            // --- Process Products Suggested by API ---
            if (queryType === 'product' && response.products && Array.isArray(response.products) && response.products.length > 0) {
                console.log("API suggested products:", response.products.map(p => p?.name || 'Invalid Product Object'));

                for (const suggestedProduct of response.products) {
                    // Validate the suggested product object structure
                    if (!suggestedProduct || typeof suggestedProduct.name !== 'string' || !suggestedProduct.name.trim()) {
                        console.warn("Skipping invalid product object from API:", suggestedProduct);
                        continue;
                    }

                    const nameToFind = suggestedProduct.name.trim().toLowerCase();
                    // Find product in local catalog (case-insensitive exact match first)
                    let foundProduct = products.find(p => p.name && p.name.toLowerCase() === nameToFind);

                    // If no exact match, try partial match (more lenient)
                    if (!foundProduct) {
                        foundProduct = products.find(p =>
                            p.name && (p.name.toLowerCase().includes(nameToFind) || nameToFind.includes(p.name.toLowerCase()))
                        );
                    }

                    if (foundProduct) {
                        // Avoid adding duplicates
                        if (!productsToShow.some(p => (p.id || p.name) === (foundProduct.id || foundProduct.name))) {
                            console.log(`Matched API suggestion "${suggestedProduct.name}" to catalog product: ${foundProduct.name}`);
                            // Add the full product details from our catalog
                            productsToShow.push({
                                ...foundProduct, // Spread operator copies all properties
                                // Ensure essential fields have defaults (already done in fetchProducts, but good practice)
                                name: foundProduct.name || "Unnamed Product",
                                description: foundProduct.description || "Description not available.",
                                price: foundProduct.price || "",
                                image: foundProduct.image, // Already HTTPSified in fetchProducts
                                url: foundProduct.url // Already validated/formatted in fetchProducts
                            });
                        }
                    } else {
                        console.log(`API suggestion "${suggestedProduct.name}" not found in local Planet Beauty catalog.`);
                        // Optionally: Could add a message here if many suggestions fail?
                    }
                }
            }

            // --- Handle Cases Where API Found No Products or Query Was Niche ---
            const queryLower = userQuery.toLowerCase();
            // Define niche terms that might not be in catalog
            const nicheTerms = ['red light', 'therapy', 'laser hair removal', 'microcurrent device'];
            const isNicheQuery = nicheTerms.some(term => queryLower.includes(term));

            if (productsToShow.length === 0 && queryType === 'product') {
                console.log("API returned no matching products or query was niche/unmatched. Running fallback search.");
                const fallbackProducts = fallbackSearch(userQuery); // Run local fallback

                if (fallbackProducts.length > 0) {
                    // If fallback finds products
                    if (isNicheQuery) {
                         // If it was a niche query, frame the results as alternatives
                         addMessage(`While Planet Beauty doesn't carry ${userQuery}, here are some related skincare products you might like: ✨`, 'bot');
                    } else {
                        // Otherwise, present them as general recommendations
                        addMessage("Okay, I found these Planet Beauty products based on your request:", 'bot');
                    }
                    // Map fallback results to the structure needed for display
                    productsToShow = fallbackProducts.map(p => ({
                        ...p,
                        name: p.name || "Unnamed Product",
                        description: p.description || "Description not available.",
                        price: p.price || "",
                        image: p.image,
                        url: p.url // Assumes URL is already validated from fetchProducts
                    }));
                } else {
                    // If fallback *also* finds nothing
                    if (isNicheQuery) {
                        addMessage(`Sorry, Planet Beauty doesn't seem to carry ${userQuery} or closely related alternatives currently. Can I help find something else, like anti-aging serums or moisturizers?`, 'bot');
                    } else {
                        addMessage("I couldn't find specific products matching your request in the Planet Beauty catalog right now. Could you try rephrasing, or ask about a different type of product?", 'bot');
                    }
                }
            }

            // --- Apply Refinements (e.g., "cheapest") ---
            // Check if the last query context indicated a preference for 'cheapest'
            if (productsToShow.length > 1 && lastQueryContext.preferences.includes('cheapest')) {
                console.log("Applying 'cheapest' refinement to results.");
                const sortedByPrice = productsToShow
                    .filter(p => p.price && typeof p.price === 'string' && p.price.match(/\d/)) // Ensure price exists and has digits
                    .sort((a, b) => {
                        const priceA = parseFloat(a.price.replace(/[^0-9.]/g, '')) || Infinity;
                        const priceB = parseFloat(b.price.replace(/[^0-9.]/g, '')) || Infinity;
                        return priceA - priceB;
                    });

                if (sortedByPrice.length > 0) {
                    // If sorting was possible, potentially update the message and limit results
                    // addMessage("Here are the most affordable options based on your request:", 'bot'); // Optional clarifying message
                    productsToShow = sortedByPrice.slice(0, 1); // Show only the cheapest one after refinement
                } else {
                    console.log("Could not apply 'cheapest' refinement (missing prices or no products left).");
                     // Maybe add a message indicating price info wasn't available for sorting
                }
            }


            // --- Display Product Cards ---
            if (productsToShow.length > 0) {
                const maxCards = 3; // Limit the number of product cards shown
                await Promise.all(productsToShow.slice(0, maxCards).map(p => addProductCard(p, userQuery)));
            }
        }


        // --- UI Functions ---
        function addMessage(text, sender) {
            const div = document.createElement('div');
            div.className = sender === 'user' ? 'user-message' : 'bot-message';
            // Sanitize HTML content from bot messages before inserting
            div.innerHTML = DOMPurify.sanitize(text, { USE_PROFILES: { html: true } }); // Allow safe HTML from bot
            chatArea.appendChild(div);

            // Animate the message appearance
            anime({
                targets: div,
                translateY: [10, 0], // Slide up effect
                opacity: [0, 1],
                duration: 400,
                easing: 'easeOutQuad'
            });

            scrollToBottom(); // Ensure view scrolls to the new message
        }

        function showTypingIndicator() {
            hideTypingIndicator(); // Remove any existing indicator first
            const div = document.createElement('div');
            div.id = 'typing-indicator';
            div.className = 'bot-message animate-fade-in'; // Use bot message style + fade in
            div.setAttribute('aria-live', 'polite'); // Announce presence to screen readers
            div.setAttribute('aria-label', 'Bot is typing');
            div.innerHTML = '<span>Thinking</span><span class="typing-dots">.</span>';
            chatArea.appendChild(div);
            scrollToBottom();

            // Animate the dots
            let dotCount = 1;
            const intervalId = setInterval(() => {
                const dotsSpan = div.querySelector('.typing-dots');
                if (dotsSpan) {
                    dotCount = (dotCount % 3) + 1; // Cycle 1, 2, 3 dots
                    dotsSpan.textContent = '.'.repeat(dotCount);
                } else {
                    clearInterval(intervalId); // Stop if element is removed
                }
            }, 400);
            // Store interval ID to clear it later
            div.dataset.intervalId = intervalId.toString();
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                const intervalId = indicator.dataset.intervalId;
                if (intervalId) {
                    clearInterval(parseInt(intervalId, 10)); // Clear the animation interval
                }
                indicator.remove(); // Remove the element from DOM
            }
        }

        function displayError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message animate-fade-in'; // Add fade-in animation
            errorDiv.setAttribute('role', 'alert'); // Indicate it's an alert message
            // Sanitize the error message itself, just in case, though it's usually internal
            const sanitizedMessage = DOMPurify.sanitize(message);
            errorDiv.innerHTML = `
                <i class="fas fa-exclamation-circle mr-2"></i> ${sanitizedMessage}
                <button class="retry-btn mt-2 text-pink-600 underline" aria-label="Retry last message">Try Again</button>
            `;

            const retryBtn = errorDiv.querySelector('.retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', () => {
                    // Find the last message sent by the user
                    const lastUserMessage = conversationHistory.filter(m => m.role === 'user').pop();
                    if (lastUserMessage?.parts?.[0]?.text) {
                        // Restore the last message to the input field and resend
                        chatInput.value = lastUserMessage.parts[0].text;
                        updateSendButtonState();
                        sendMessage(); // Trigger send again
                        errorDiv.remove(); // Remove the error message on retry
                    } else {
                        // If history is lost or empty
                        addMessage("Could not retrieve the last message to retry. Please type your message again.", 'bot');
                        errorDiv.remove();
                    }
                });
            }

            chatArea.appendChild(errorDiv);
            scrollToBottom();
        }

        async function addProductCard(p, queryContext) {
            // --- Strict URL Validation ---
            let finalUrl = p.url || formatProductUrl(p.name); // Start with provided or formatted URL
            try {
                 // Ensure it's an absolute URL starting with the correct domain
                 const parsed = new URL(finalUrl);
                 if (!parsed.hostname.endsWith('planetbeauty.com')) {
                     console.warn(`Correcting non-Planet Beauty URL in product card for ${p.name}: ${finalUrl}`);
                     finalUrl = formatProductUrl(p.name); // Re-format to ensure domain
                 }
                 // Ensure HTTPS
                 finalUrl = finalUrl.replace(/^http:/, 'https:');
            } catch(e) {
                 console.error(`Invalid URL generated for product ${p.name}: ${finalUrl}. Defaulting.`);
                 finalUrl = PLANET_BEAUTY_DOMAIN; // Default to homepage on error
            }
             // Final safety check
             if (!finalUrl.startsWith(PLANET_BEAUTY_DOMAIN)) {
                 console.error(`URL validation failed for ${p.name}. Defaulting to homepage.`);
                 finalUrl = PLANET_BEAUTY_DOMAIN;
             }


            const card = document.createElement('a');
            card.href = finalUrl; // Use the validated URL
            card.target = '_blank'; // Open in new tab
            card.rel = 'noopener noreferrer'; // Security best practice
            card.className = 'product-card animate-fade-in'; // Styling and animation
            card.setAttribute('aria-label', `View product: ${p.name || 'Product'}`); // Accessibility
            card.addEventListener('click', () => {
                // Track product clicks
                if (typeof gtag === 'function') {
                    gtag('event', 'product_click', {
                        event_category: 'Chatbot',
                        event_label: p.name || 'Unknown Product',
                        value: finalUrl // Send URL as value
                     });
                }
            });

            // --- Image Loading with Fallback ---
            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-loading'; // Shows spinner initially
            const spinner = document.createElement('div');
            spinner.className = 'spinner';
            imageContainer.appendChild(spinner);
            card.appendChild(imageContainer);

            const img = document.createElement('img');
            img.alt = p.name ? `Image of ${p.name}` : "Product Image"; // Descriptive alt text
            img.className = 'product-image lazyload'; // Add lazyload class
            img.style.display = 'none'; // Hide initially until loaded

            // Prepare image sources: primary, category backup, default backup
            const imageSources = [
                p.image, // Primary image (already HTTPSified)
                getBackupImage(p.name || queryContext), // Category-specific backup
                backupImages.default // Global default backup
            ].filter(url => url && typeof url === 'string' && url.trim() !== ''); // Filter out invalid/empty URLs

            let currentAttempt = 0;

            const tryLoadNextImage = () => {
                if (currentAttempt >= imageSources.length) {
                    // All attempts failed, show placeholder
                    console.warn(`Failed to load any image for product: ${p.name || 'Unknown'}`);
                    imageContainer.innerHTML = `<div class="image-placeholder"><span>Image Not Available</span></div>`;
                    // Ensure placeholder is visible if image loading container was already replaced
                    if (!card.contains(imageContainer)) {
                         const infoDiv = card.querySelector('.product-info');
                         if (infoDiv) card.insertBefore(imageContainer, infoDiv);
                         else card.appendChild(imageContainer);
                    }
                    img.style.display = 'none'; // Ensure img element is hidden
                    return;
                }

                const url = imageSources[currentAttempt];
                console.log(`Image Load Attempt ${currentAttempt + 1} for ${p.name || 'Unknown'}: ${url}`);

                img.onload = null; // Clear previous handlers
                img.onerror = null;

                img.onload = () => {
                    console.log(`Image loaded successfully: ${img.src}`);
                    img.style.display = 'block'; // Show the image
                    img.classList.add('lazyloaded'); // Mark as loaded for potential CSS transitions
                    if (imageContainer.parentNode) {
                        imageContainer.replaceWith(img); // Replace spinner container with image
                    }
                };

                img.onerror = () => {
                    console.warn(`Image Load Attempt ${currentAttempt + 1} failed for URL: ${url}`);
                    currentAttempt++;
                    tryLoadNextImage(); // Try the next source
                };

                // Use data-src for lazysizes if preferred, or just src
                // img.setAttribute('data-src', url); // For lazysizes
                img.src = url; // Direct loading might be simpler here
            };

            tryLoadNextImage(); // Start loading attempts

            // --- Product Information ---
            const MAX_TITLE_LENGTH = 60; // Slightly longer title allowed
            const MAX_DESC_LENGTH = 120; // Slightly longer description

            const productName = p.name || "Unnamed Product";
            const productDesc = p.description || "Click for details.";

            // Truncate text for display, use full text in title attribute for tooltips
            const truncatedName = productName.length > MAX_TITLE_LENGTH
                ? productName.substring(0, MAX_TITLE_LENGTH) + '...'
                : productName;
            const truncatedDesc = productDesc.length > MAX_DESC_LENGTH
                ? productDesc.substring(0, MAX_DESC_LENGTH) + '...'
                : productDesc;

            const infoDiv = document.createElement('div');
            infoDiv.className = 'product-info';
            // Sanitize all text content before inserting as HTML
            infoDiv.innerHTML = `
                <div class="product-name" title="${DOMPurify.sanitize(productName)}">${DOMPurify.sanitize(truncatedName)}</div>
                <div class="product-description">${DOMPurify.sanitize(truncatedDesc)}</div>
                <div class="product-price">${p.price ? DOMPurify.sanitize(p.price) : ""}</div>
            `;

            card.appendChild(infoDiv);
            chatArea.appendChild(card); // Add the complete card to the chat
            scrollToBottom(); // Scroll to make it visible
        }


        function scrollToBottom() {
            // Use requestAnimationFrame for smoother scrolling after DOM updates
            requestAnimationFrame(() => {
                chatArea.scrollTop = chatArea.scrollHeight;
            });
        }

        function updateUserProfile(botResponseText) {
            // Basic profile update based on keywords in bot response (can be expanded)
            if (typeof botResponseText !== 'string') return;

            const textLower = botResponseText.toLowerCase();
            let updated = false;
            const newProfile = { ...userProfile }; // Copy current profile

            // Example: Infer skin type
            if (textLower.includes('dry skin') && newProfile.skinType !== 'Dry') {
                newProfile.skinType = 'Dry'; updated = true;
            } else if (textLower.includes('oily skin') && newProfile.skinType !== 'Oily') {
                newProfile.skinType = 'Oily'; updated = true;
            } else if (textLower.includes('combination skin') && newProfile.skinType !== 'Combination') {
                newProfile.skinType = 'Combination'; updated = true;
            } else if (textLower.includes('sensitive skin') && newProfile.skinType !== 'Sensitive') {
                newProfile.skinType = 'Sensitive'; updated = true;
            }

            // Example: Infer concerns
            if (textLower.includes('acne') && !newProfile.concerns.includes('Acne')) {
                newProfile.concerns.push('Acne'); updated = true;
            }
            if ((textLower.includes('wrinkles') || textLower.includes('fine lines') || textLower.includes('anti-aging')) && !newProfile.concerns.includes('Aging')) {
                newProfile.concerns.push('Aging'); updated = true;
            }
            if (textLower.includes('dullness') && !newProfile.concerns.includes('Dullness')) {
                newProfile.concerns.push('Dullness'); updated = true;
            }

            if (updated) {
                Object.assign(userProfile, newProfile); // Update the global profile state
                console.log(`User profile inferred - Skin Type: ${userProfile.skinType || 'N/A'}, Concerns: ${userProfile.concerns.join(', ') || 'None'}`);
            }
        }

        function updateQueryContext(query) {
            const queryLower = query.toLowerCase();
            let foundCategory = null;
            // Detect primary product type/category from the query
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => queryLower.includes(keyword))) {
                    foundCategory = category;
                    break; // Use the first matched category as primary context
                }
            }
            // Only update productType if a new one is detected, otherwise keep the old one for refinement context
            if (foundCategory) {
                 lastQueryContext.productType = foundCategory;
            }


            // Detect preferences (like 'cheapest')
            if (queryLower.includes('cheapest') || queryLower.includes('cheaper') || queryLower.includes('affordable') || queryLower.includes('lowest price')) {
                lastQueryContext.preferences = ['cheapest'];
            } else {
                // Reset preferences if the query doesn't indicate one (or handle other preferences)
                lastQueryContext.preferences = [];
            }
            console.log('Updated query context:', lastQueryContext);
        }

    </script>
</body>
</html>
