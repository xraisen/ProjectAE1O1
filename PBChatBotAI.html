<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Planet Beauty AI Chatbot - Find personalized beauty products with our interactive assistant.">
    <link rel="icon" href="https://via.placeholder.com/16x16/E91e63/FFFFFF?text=PB" type="image/png">
    <title>Planet Beauty AI Chatbot</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DLVD913P7M"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-DLVD913P7M'); // Replace with your GA ID
    </script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f8f9fa;
            margin: 0;
            overflow-x: hidden;
        }
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #e91e63;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        #preloader .percentage {
            font-size: 1.5rem;
            font-weight: 500;
            color: #e91e63;
        }
        .chat-container {
            max-width: 900px;
            margin: 0 auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 12px;
            background: white;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 140px);
            max-height: 800px;
        }
        .chat-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
            will-change: scroll-position;
        }
        .user-message {
            background: #e91e63;
            color: white;
            padding: .75rem 1rem;
            border-radius: 15px 15px 0 15px;
            max-width: 80%;
            margin-left: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .bot-message {
            background: #f0f0f0;
            color: #333;
            padding: .75rem 1rem;
            border-radius: 15px 15px 15px 0;
            max-width: 80%;
            margin-right: auto;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .product-card {
            display: block;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            margin: 1rem 0;
            text-decoration: none;
            color: inherit;
            background: white;
            max-width: 80%;
            margin-right: auto;
        }
        .product-card:hover {
            transform: scale(1.03);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .product-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }
        .lazyload, .lazyloading {
            opacity: 0;
            transition: opacity 0.3s;
        }
        .lazyloaded {
            opacity: 1;
        }
        .image-loading {
            position: relative;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f5f5f5;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(233, 30, 99, 0.2);
            border-top-color: #e91e63;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .image-placeholder {
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #eee;
            color: #666;
            font-size: 0.9em;
            text-align: center;
        }
        .product-info {
            padding: 1rem;
        }
        .product-name {
            font-weight: 600;
            margin-bottom: .25rem;
        }
        .product-description {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: .5rem;
        }
        .product-price {
            font-weight: 500;
            color: #e91e63;
        }
        .examples-container {
            display: flex;
            flex-wrap: wrap;
            gap: .5rem;
            margin-bottom: 1rem;
            max-width: 80%;
        }
        .example-chip {
            padding: .5rem 1rem;
            background: #f0f0f0;
            border: 1px solid #e0e0e0;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s, box-shadow 0.2s;
            font-size: 0.9rem;
        }
        .example-chip:hover {
            background: #e91e63;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .example-chip:focus {
            outline: 2px solid #e91e63;
            outline-offset: 2px;
        }
        .input-area {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #eee;
            background: #fff;
        }
        .input-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        input[type=text] {
            flex: 1;
            padding: .75rem 1rem;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            transition: border-color 0.3s;
        }
        input[type=text]:focus {
            border-color: #e91e63;
        }
        input[type=text]:disabled {
            background-color: #f5f5f5;
        }
        .send-btn {
            background: #e91e63;
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            flex-shrink: 0;
        }
        .send-btn:hover {
            background: #d81b60;
            transform: scale(1.05);
        }
        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: .75rem 1rem;
            border-radius: 15px;
            margin-bottom: 1rem;
            max-width: 80%;
            margin-right: auto;
            border: 1px solid #f4c7c7;
        }
        .retry-btn {
            background: none;
            border: none;
            color: #e91e63;
            text-decoration: underline;
            cursor: pointer;
        }
        footer {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 0.5rem 1rem;
            color: #6c757d;
            font-size: 0.875rem;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        footer a {
            color: #e91e63;
            text-decoration: none;
            margin-left: 0.25rem;
        }
        footer a:hover {
            text-decoration: underline;
        }
        #typing-indicator .typing-dots {
            display: inline-block;
            width: 1.5em;
            text-align: left;
            vertical-align: bottom;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @media (max-width: 640px) {
            body {
                padding: 0;
            }
            .chat-container {
                border-radius: 0;
                max-width: 100%;
                height: 100vh;
                max-height: none;
                margin: 0;
            }
            .chat-area {
                padding: 1rem;
            }
            .user-message, .bot-message, .product-card, .examples-container, .error-message {
                max-width: 90%;
            }
            .input-area {
                padding: 0.75rem;
            }
            input[type=text] {
                padding: 0.6rem 0.9rem;
            }
            .send-btn {
                width: 40px;
                height: 40px;
            }
            footer {
                font-size: 0.8rem;
                padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
            }
            #preloader .percentage {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <div id="preloader">
        <div class="spinner"></div>
        <div class="percentage">0%</div>
    </div>
    <header class="text-center py-6 px-4 flex-shrink-0 bg-gradient-to-r from-pink-600 to-purple-700 text-white shadow-md animate-fade-in">
        <h1 class="text-3xl sm:text-4xl font-bold">Planet Beauty</h1>
        <p class="text-lg sm:text-xl">Your AI Beauty Assistant ✨</p>
    </header>

    <main class="chat-container flex-grow animate-fade-in">
        <div id="chat-area" class="chat-area">
            <div class="bot-message">Hi there! Welcome to Planet Beauty's AI Assistant. ✨ How can I help you find the perfect products today?</div>
            <div id="examples-container" class="examples-container"></div>
        </div>

        <div class="input-area">
            <div class="input-row">
                <input id="chat-input" type="text" placeholder="Ask about beauty products..." autocomplete="off" aria-label="Type your beauty product question">
                <button id="send-btn" class="send-btn" disabled aria-label="Send message"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </main>

    <footer>
        <span>Developed with ❤️ by</span>
        <a href="https://www.linkedin.com/in/joseespinosa" target="_blank" rel="noopener noreferrer">Jose Espinosa</a>
    </footer>

    <script>
        // --- Configuration ---
        const GEMINI_API_KEY = 'AIzaSyCpI-eNfqWk_ZiK2qHOj_tD2NzeAJ_U398'; // Replace with your Gemini API key
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzzp5mD6Nu3RZmYvjzDFXvCNC5MhJyfNMvs_MJDYLqZ8Uad1BJE-cO1WWg7BpoYO62_/exec'; // Replace with your deployed Web App URL
        const API_TIMEOUT = 15000;
        const IMAGE_TIMEOUT = 15000;
        const PRELOADER_MIN_DURATION = 1000;
        const PERCENTAGE_ANIMATION_DURATION = 2000;

        // --- Fallback Questions ---
        const FALLBACK_QUESTIONS = [
            "What are the best anti-aging serums for dry skin?",
            "Can you recommend a hydrating serum for sensitive skin?",
            "What's a good cleanser for combination skin?",
            "Which makeup is ideal for a natural look?"
        ];

        // --- Niche Queries Handling ---
        const nicheQueries = {
            'red light therapy': {
                message: "Planet Beauty doesn't carry red light therapy devices. Here are some anti-aging serums for skin rejuvenation, ideal for dry skin: ✨",
                fallbackCategory: 'serum',
                relatedConcerns: ['Aging', 'Dullness', 'Dryness']
            },
            'led therapy': {
                message: "Planet Beauty doesn't carry LED therapy devices. Try these anti-aging serums for brightening and hydration: ✨",
                fallbackCategory: 'serum',
                relatedConcerns: ['Dullness', 'Aging', 'Dryness']
            }
        };

        // --- State ---
        const userProfile = { skinType: null, skinTone: null, concerns: [] };
        let conversationHistory = [];
        const MAX_HISTORY = 10; // Retain 5 user-model pairs
        const imageCache = JSON.parse(localStorage.getItem('imageCache')) || {};
        let products = [];
        let productCategories = {};
        let lastQueryContext = { productType: null, preferences: [], queryKeywords: [] };
        const backupImages = {
            default: 'https://via.placeholder.com/600x400/E91e63/FFFFFF?text=Planet+Beauty',
        };

        // --- Category Keywords ---
        const categoryKeywords = {
            acne: ['acne', 'blemish', 'pimple', 'breakout', 'clear skin', 'oily'],
            moisturizer: ['moisturizer', 'hydrating', 'dry skin', 'hydration', 'cream'],
            shampoo: ['shampoo', 'hair wash', 'clean hair'],
            conditioner: ['conditioner', 'soften hair', 'detangle'],
            hairmask: ['hair mask', 'treatment', 'damaged hair', 'repair hair'],
            foundation: ['foundation', 'makeup base', 'cover', 'complexion', 'tone'],
            serum: ['serum', 'essence', 'concentrate', 'anti-aging', 'hydrating', 'rejuvenation', 'vitamin c', 'retinol', 'hyaluronic acid'],
            cleanser: ['cleanser', 'face wash', 'wash'],
            exfoliant: ['exfoliant', 'scrub', 'peel', 'smooth skin'],
            styling: ['styling', 'hairspray', 'texture', 'volume', 'hold'],
            skincare: ['skincare', 'face care', 'complexion', 'skin health', 'rejuvenation'],
            haircare: ['haircare', 'hair product', 'mane'],
            sunscreen: ['sunscreen', 'spf', 'uv', 'protection']
        };

        // --- DOM Elements ---
        const chatArea = document.getElementById('chat-area');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const preloader = document.getElementById('preloader');
        const examplesContainer = document.getElementById('examples-container');

        // --- Utility Functions ---
        function simpleFuzzyMatch(str1, str2) {
            str1 = str1.toLowerCase().replace(/[^\w\s]/g, '');
            str2 = str2.toLowerCase().replace(/[^\w\s]/g, '');
            if (str1 === str2) return 1.0;
            if (str1.includes(str2) || str2.includes(str1)) return 0.8;
            let matches = 0;
            const words1 = str1.split(/\s+/);
            const words2 = str2.split(/\s+/);
            words1.forEach(word => {
                if (words2.includes(word)) matches++;
            });
            return matches / Math.max(words1.length, words2.length, 1);
        }

        function extractProductInfo(query) {
            const queryLower = query.toLowerCase();
            const urlMatch = query.match(/https:\/\/www\.planetbeauty\.com\/products\/([^\s]+)/);
            let productName = null;
            let productUrl = null;

            if (urlMatch) {
                productUrl = urlMatch[0];
                productName = urlMatch[1].replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
            } else {
                const nameMatch = query.match(/["']([^"']+)["']/);
                if (nameMatch) {
                    productName = nameMatch[1];
                } else {
                    const words = queryLower.split(/\s+/);
                    const potentialName = words.slice(words.findIndex(w => w === 'product') + 1).join(' ');
                    if (potentialName) {
                        productName = potentialName.replace(/\b\w/g, c => c.toUpperCase());
                    }
                }
            }

            return { productName, productUrl };
        }

        function findProductByNameOrUrl(productName, productUrl) {
            if (!productName && !productUrl) return null;

            let foundProduct = null;
            if (productName) {
                const nameLower = productName.toLowerCase();
                foundProduct = products.find(p => p.name && p.name.toLowerCase() === nameLower);
                if (!foundProduct) {
                    const scores = products.map(p => ({
                        product: p,
                        score: simpleFuzzyMatch(nameLower, (p.name || "").toLowerCase())
                    }));
                    const bestMatch = scores.reduce((best, curr) => curr.score > best.score ? curr : best, { score: 0 });
                    if (bestMatch.score > 0.6) {
                        foundProduct = bestMatch.product;
                    }
                }
            }

            if (!foundProduct && productUrl) {
                foundProduct = products.find(p => p.url && p.url.toLowerCase() === productUrl.toLowerCase());
            }

            return foundProduct;
        }

        function validateProductCategory(product, desiredCategory, skinType = null) {
            if (!product || !desiredCategory) return false;
            const nameLower = (product.name || "").toLowerCase();
            const descLower = (product.description || "").toLowerCase();
            const categories = product.categories || [];

            // Check if product matches the desired category
            if (!categories.includes(desiredCategory) && !categoryKeywords[desiredCategory].some(kw => nameLower.includes(kw) || descLower.includes(kw))) {
                return false;
            }

            // Additional validation for skin type (e.g., dry skin)
            if (skinType === 'dry') {
                const drySkinKeywords = ['hydrating', 'moisturizing', 'dry skin', 'hyaluronic acid', 'non-irritating', 'gentle'];
                return drySkinKeywords.some(kw => nameLower.includes(kw) || descLower.includes(kw));
            }

            return true;
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            let percentage = 0;
            const percentageElement = preloader.querySelector('.percentage');
            const animatePercentage = () => {
                return new Promise(resolve => {
                    anime({
                        targets: { value: percentage },
                        value: 90,
                        duration: PERCENTAGE_ANIMATION_DURATION,
                        easing: 'easeOutQuad',
                        update: (anim) => {
                            percentage = Math.round(anim.animatables[0].target.value);
                            percentageElement.textContent = `${percentage}%`;
                        },
                        complete: () => resolve()
                    });
                });
            };

            const minDurationPromise = new Promise(resolve => setTimeout(resolve, PRELOADER_MIN_DURATION));
            const animationPromise = animatePercentage();
            try {
                products = await fetchProducts();
                categorizeProducts();
                await generateSuggestedQuestions();
                await Promise.all([minDurationPromise, animationPromise]);
                await anime({
                    targets: { value: percentage },
                    value: 100,
                    duration: 300,
                    easing: 'easeOutQuad',
                    update: (anim) => {
                        percentageElement.textContent = `${Math.round(anim.animatables[0].target.value)}%`;
                    }
                }).finished;
                preloader.style.opacity = '0';
                setTimeout(() => preloader.remove(), 500);
            } catch (error) {
                console.error('Initialization error:', error);
                percentageElement.textContent = 'Error';
                percentageElement.style.color = '#c62828';
                await Promise.all([minDurationPromise, animationPromise]);
                preloader.style.opacity = '0';
                setTimeout(() => preloader.remove(), 500);
                addMessage("Sorry, I couldn't load the product catalog. Please try again later.", 'bot');
            }

            anime({
                targets: 'header',
                translateY: [-20, 0],
                opacity: [0, 1],
                duration: 800,
                easing: 'easeOutQuad'
            });

            chatInput.addEventListener('keyup', handleInputKeyup);
            chatInput.addEventListener('input', handleInputChange);
            sendBtn.addEventListener('click', () => {
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            });
            chatInput.focus();
            updateSendButtonState();
        });

        // --- Fetch Products ---
        async function fetchProducts() {
            try {
                const res = await axios.get(WEB_APP_URL, { timeout: API_TIMEOUT });
                if (res.data && res.data.products) {
                    products = res.data.products
                        .map((p, index) => ({
                            ...p,
                            id: p.id || `p${index + 1}`,
                            image: p.image && typeof p.image === 'string' && p.image.startsWith('http://') ? p.image.replace('http://', 'https://') : p.image,
                            url: p.url && p.url.includes('planetbeauty.com') ? p.url : formatProductUrl(p.name)
                        }))
                        .filter(p => p.url && p.url.includes('planetbeauty.com')); // Strict domain filter
                    console.log("Products loaded from Web App:", products.length);
                    return products;
                } else if (res.data && res.data.error) {
                    throw new Error(`Web App Error: ${res.data.error}`);
                } else {
                    throw new Error("Invalid data format received from Web App.");
                }
            } catch (error) {
                console.error('Failed to fetch products:', error);
                throw error;
            }
        }

        // --- Categorize Products ---
        function categorizeProducts() {
            if (!products || products.length === 0) return;
            const categoryMap = new Map();
            products.forEach(product => {
                product.categories = [];
                for (const [category, keywords] of Object.entries(categoryKeywords)) {
                    if (keywords.some(keyword =>
                        (product.name && typeof product.name === 'string' && product.name.toLowerCase().includes(keyword)) ||
                        (product.description && typeof product.description === 'string' && product.description.toLowerCase().includes(keyword)))) {
                        product.categories.push(category);
                        if (!categoryMap.has(category)) {
                            categoryMap.set(category, []);
                        }
                        categoryMap.get(category).push(product);
                    }
                }
            });
            productCategories = Object.fromEntries(categoryMap);
            for (const category of Object.keys(productCategories)) {
                backupImages[category] = productCategories[category]
                    .map(p => p.image)
                    .filter(img => img && typeof img === 'string');
            }
        }

        // --- Suggested Questions ---
        async function generateSuggestedQuestions() {
            try {
                const questions = await fetchSuggestedQuestions();
                displaySuggestedQuestions(questions);
            } catch (error) {
                console.error('Failed to generate suggested questions:', error);
                displaySuggestedQuestions(FALLBACK_QUESTIONS);
            }
        }

        async function fetchSuggestedQuestions() {
            const prompt = {
                contents: [{
                    role: 'user',
                    parts: [{
                        text: `Generate 4 concise, varied, and helpful beauty-related questions for a chatbot exclusive to Planet Beauty (https://www.planetbeauty.com/). Questions must focus on skincare, haircare, or makeup products available in the Planet Beauty catalog, addressing common user needs (e.g., recommendations for specific skin types or hair concerns). Return the response as a JSON array of strings. Example:
                        ["What's the best anti-aging serum for dry skin at Planet Beauty?", "Can you recommend a hydrating serum for sensitive skin from Planet Beauty?", "What foundation suits combination skin at Planet Beauty?", "Which shampoo helps with dry hair at Planet Beauty?"]`
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topP: 0.95,
                    topK: 40,
                    maxOutputTokens: 256,
                    responseMimeType: 'application/json'
                },
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                ]
            };

            try {
                const res = await axios.post(GEMINI_API_URL, prompt, {
                    headers: { 'Content-Type': 'application/json' },
                    timeout: API_TIMEOUT
                });

                if (res.data && res.data.candidates && res.data.candidates[0] &&
                    res.data.candidates[0].content && res.data.candidates[0].content.parts &&
                    res.data.candidates[0].content.parts[0] && res.data.candidates[0].content.parts[0].text) {
                    const responseText = res.data.candidates[0].content.parts[0].text;
                    const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                    const questions = JSON.parse(cleanedText);
                    if (Array.isArray(questions) && questions.length >= 4 && questions.every(q => typeof q === 'string')) {
                        return questions.slice(0, 4);
                    }
                }
                throw new Error('Failed to fetch valid questions.');
            } catch (error) {
                console.error('Error fetching suggested questions:', error);
                throw error;
            }
        }

        function displaySuggestedQuestions(questions) {
            examplesContainer.innerHTML = '';
            if (!Array.isArray(questions)) {
                console.error("Cannot display suggestions: input is not an array.", questions);
                questions = FALLBACK_QUESTIONS;
            }
            questions.forEach((question, index) => {
                if (typeof question !== 'string') {
                    console.warn(`Skipping invalid suggestion at index ${index}:`, question);
                    return;
                }
                const chip = document.createElement('div');
                chip.className = 'example-chip';
                chip.setAttribute('data-q', question);
                chip.setAttribute('role', 'button');
                chip.tabIndex = 0;
                chip.setAttribute('aria-label', `Ask: ${question}`);
                chip.textContent = question;
                chip.addEventListener('click', handleExampleClick);
                chip.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleExampleClick(e);
                    }
                });
                examplesContainer.appendChild(chip);
            });

            anime({
                targets: '.example-chip',
                translateX: [-20, 0],
                opacity: [0, 1],
                delay: anime.stagger(100),
                duration: 600,
                easing: 'easeOutQuad'
            });
        }

        // --- Utilities ---
        function formatProductUrl(productName) {
            if (!productName || typeof productName !== 'string') {
                return 'https://www.planetbeauty.com/';
            }
            return 'https://www.planetbeauty.com/products/' +
                productName.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .trim()
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-');
        }

        function getBackupImage(query) {
            const queryLower = (query || "").toLowerCase();
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => queryLower.includes(keyword))) {
                    const imageArray = backupImages[category] || [];
                    if (imageArray.length > 0) {
                        return imageArray[Math.floor(Math.random() * imageArray.length)];
                    }
                }
            }
            return backupImages.default;
        }

        // --- Event Handlers ---
        function handleExampleClick(event) {
            const query = event.currentTarget.getAttribute('data-q');
            if (query) {
                chatInput.value = query;
                updateSendButtonState();
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'example_chip_click', { event_category: 'Chatbot', event_label: query });
                }
            }
        }

        function handleInputKeyup(event) {
            if (event.key === 'Enter' && !sendBtn.disabled) {
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            }
        }

        function handleInputChange() {
            updateSendButtonState();
        }

        function updateSendButtonState() {
            sendBtn.disabled = chatInput.value.trim() === '';
        }

        // --- Core Functions ---
        async function sendMessage() {
            const rawMessage = chatInput.value.trim();
            if (!rawMessage) return;

            const message = DOMPurify.sanitize(rawMessage, { USE_PROFILES: { html: false } });
            addMessage(message, 'user');
            const userMessageEntry = { role: 'user', parts: [{ text: message }] };
            conversationHistory.push(userMessageEntry);

            // Update query context
            updateQueryContext(message);

            chatInput.value = '';
            updateSendButtonState();
            chatInput.disabled = true;
            sendBtn.disabled = true;

            showTypingIndicator();

            try {
                const response = await callGeminiAPI();
                await processResponse(response, message);
            } catch (error) {
                console.error('Error:', error);
                hideTypingIndicator();
                const errorMessage = error.message.includes('timed out')
                    ? "The request timed out. Please try again."
                    : "I encountered an issue. Please try again.";
                displayError(errorMessage);
                const fallbackProducts = fallbackSearch(message);
                if (fallbackProducts.length > 0) {
                    addMessage("Here are some Planet Beauty products that might match your request:", 'bot');
                    await Promise.all(fallbackProducts.map(p => addProductCard(p, message)));
                } else {
                    addMessage("I couldn't find matching products in Planet Beauty's catalog. Try rephrasing or ask about another beauty product!", 'bot');
                }
            } finally {
                chatInput.disabled = false;
                updateSendButtonState();
                chatInput.focus();
                if (conversationHistory.length > MAX_HISTORY) {
                    conversationHistory = conversationHistory.slice(-MAX_HISTORY);
                }
            }
        }

        async function callGeminiAPI(retry = false) {
            try {
                const prompt = createPrompt();
                const payload = {
                    contents: prompt,
                    generationConfig: {
                        temperature: 0.4,
                        topP: 0.95,
                        topK: 40,
                        maxOutputTokens: 1024,
                        responseMimeType: 'application/json'
                    },
                    safetySettings: [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                    ]
                };

                const res = await axios.post(GEMINI_API_URL, payload, {
                    headers: { 'Content-Type': 'application/json' },
                    timeout: API_TIMEOUT
                });

                if (res.data && res.data.candidates && res.data.candidates[0] &&
                    res.data.candidates[0].content && res.data.candidates[0].content.parts &&
                    res.data.candidates[0].content.parts[0] && res.data.candidates[0].content.parts[0].text) {
                    const responseText = res.data.candidates[0].content.parts[0].text;
                    try {
                        const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                        const parsedResponse = JSON.parse(cleanedText);
                        if (typeof parsedResponse !== 'object' || !parsedResponse.text || !parsedResponse.query_type || !Array.isArray(parsedResponse.products)) {
                            throw new Error('Invalid response structure');
                        }
                        conversationHistory.push({ role: 'model', parts: [{ text: cleanedText }] });
                        return parsedResponse;
                    } catch (parseError) {
                        console.error('JSON Parse Error:', parseError, 'Raw:', responseText);
                        return { text: "I understood your request, but let me find some products for you.", query_type: 'other', products: [] };
                    }
                } else if (res.data && res.data.promptFeedback && res.data.promptFeedback.blockReason) {
                    throw new Error(`Request blocked: ${res.data.promptFeedback.blockReason}. Please rephrase.`);
                } else {
                    throw new Error('Unexpected response format');
                }
            } catch (error) {
                if (!retry && error.message.includes('timed out')) {
                    console.log('Retrying API call due to timeout...');
                    return await callGeminiAPI(true);
                }
                throw error;
            }
        }

        function createPrompt() {
            const recentQueries = conversationHistory
                .filter(entry => entry.role === 'user')
                .slice(-3)
                .map(entry => entry.parts[0].text)
                .join('; ');
            const contextSummary = recentQueries
                ? `Recent user queries: ${recentQueries}. Current intent: ${lastQueryContext.productType || 'none'}, preferences: ${lastQueryContext.preferences.join(', ') || 'none'}, keywords: ${lastQueryContext.queryKeywords.join(', ') || 'none'}`
                : 'No recent queries.';

            const systemInstruction = {
                role: 'user',
                parts: [{
                    text: `You are a friendly AI assistant for Planet Beauty (https://www.planetbeauty.com/). Your goal is to assist users with beauty product queries using ONLY products from the Planet Beauty catalog provided via Google Sheet. All product recommendations must have URLs under https://www.planetbeauty.com/. Engage in natural, companion-like conversation, maintaining context from recent queries. For each user message, determine the query type and respond accordingly.

- If the user provides a specific product name or URL (e.g., "Dr. Dennis Gross Skincare Spectralite Faceware Pro" or "https://www.planetbeauty.com/products/dr-dennis-gross-skincare-spectralite-faceware-pro"), set "query_type": "specific_product" and focus on that product. Confirm its presence in the catalog, describe its intended use (e.g., benefits, skin type), and return it in the "products" array with exact "name" matching the catalog. If not found, return an empty products array and suggest relevant catalog alternatives.
- If the user asks for a specific product category like "serums" (e.g., "anti-aging serums for dry skin"), set "query_type": "product" and ONLY recommend products categorized as serums (names or descriptions containing "serum" or "essence"). Filter for skin type (e.g., dry skin: hydrating, moisturizing, non-irritating) and concerns (e.g., anti-aging: retinol, vitamin C, hyaluronic acid).
- If the user mentions red light therapy or LED therapy, set "query_type": "product" and note that Planet Beauty does not carry red light therapy devices. Suggest anti-aging serums that promote skin rejuvenation and hydration, suitable for the specified skin type (e.g., dry skin).
- If the user greets or engages casually (e.g., "hi," "hello"), set "query_type": "greeting" and respond friendly without products.
- For general product recommendations or beauty concerns (e.g., "products for dry skin"), set "query_type": "product" and provide a concise response (max 150 words) with 1-3 product recommendations from the Planet Beauty catalog ONLY. Each product in the "products" array must have a "name" key matching a catalog entry exactly.
- For other messages (e.g., "thank you," store hours), set "query_type": "other" and respond appropriately without products.
- If the user refines a previous request (e.g., "cheapest" after asking for serums), use the conversation history to filter recommendations (e.g., lowest price for serums).
- Ensure all product URLs are under https://www.planetbeauty.com/.

Always return a JSON object with "text" (your reply, including why products are recommended), "query_type" (specific_product, greeting, product, other), and "products" (array of product objects or empty). Use the conversation history and context: ${contextSummary}.

Examples:
1. User: Which anti-aging serums does Planet Beauty carry that are effective for dry skin?
Assistant: {"text": "For anti-aging and dry skin, I recommend these hydrating serums from Planet Beauty: ✨ The Murad Retinol Youth Renewal Serum reduces fine lines with retinol while being gentle for dry skin. The Dermalogica Biolumin-C Serum boosts radiance with vitamin C and hydrates without irritation.", "query_type": "product", "products": [{"name": "Murad Retinol Youth Renewal Serum"}, {"name": "Dermalogica Biolumin-C Serum"}]}
2. User: Red light therapy
Assistant: {"text": "Planet Beauty doesn't carry red light therapy devices. For similar anti-aging and rejuvenation benefits, try these serums: ✨ The Murad Retinol Youth Renewal Serum minimizes wrinkles and hydrates dry skin. The Dermalogica Biolumin-C Serum brightens and moisturizes.", "query_type": "product", "products": [{"name": "Murad Retinol Youth Renewal Serum"}, {"name": "Dermalogica Biolumin-C Serum"}]}
3. User: Hi
Assistant: {"text": "Hello! How can I assist you with Planet Beauty products today?", "query_type": "greeting", "products": []}
4. User: Cheapest serum
Assistant: {"text": "Here’s the most affordable anti-aging serum for dry skin from Planet Beauty:", "query_type": "product", "products": [{"name": "Product Name"}]}
5. User: Thank you!
Assistant: {"text": "You're welcome! Need help with more Planet Beauty products?", "query_type": "other", "products": []}`
                }]
            };
            const validHistory = conversationHistory.filter(entry => entry.role && entry.parts && Array.isArray(entry.parts));
            return [systemInstruction, ...validHistory];
        }

        function fallbackSearch(query, context = lastQueryContext) {
            const queryLower = (query || "").toLowerCase();
            if (!queryLower || products.length === 0) return [];

            const { productName, productUrl } = extractProductInfo(query);
            if (productName || productUrl) {
                const foundProduct = findProductByNameOrUrl(productName, productUrl);
                if (foundProduct && validateProductCategory(foundProduct, context.productType || 'serum', context.skinType)) {
                    return [foundProduct];
                }
            }

            const keywords = queryLower.split(/\s+/)
                .filter(word => word.length > 2 && !['the', 'a', 'an', 'is', 'for', 'what', 'can', 'you', 'recommend', 'find', 'me', 'i', 'need', 'with', 'of', 'my', 'skin', 'hair'].includes(word));

            let matchedProducts = [];
            const isRefinement = keywords.some(k => ['cheapest', 'cheaper', 'affordable', 'lowest'].includes(k));

            // Handle niche queries
            for (const [nicheQuery, config] of Object.entries(nicheQueries)) {
                if (queryLower.includes(nicheQuery)) {
                    const categoryProducts = productCategories[config.fallbackCategory] || [];
                    if (categoryProducts.length > 0) {
                        return categoryProducts
                            .filter(p => validateProductCategory(p, 'serum', 'dry') &&
                                config.relatedConcerns.some(concern => userProfile.concerns.includes(concern) || true))
                            .slice(0, 3);
                    }
                    return [];
                }
            }

            // Refinement (e.g., cheapest)
            if (isRefinement && context.productType) {
                matchedProducts = products
                    .filter(p => validateProductCategory(p, context.productType, context.skinType) &&
                        p.price && typeof p.price === 'string' && p.price.includes('$'))
                    .sort((a, b) => {
                        const priceA = parseFloat(a.price.replace('$', '')) || Infinity;
                        const priceB = parseFloat(b.price.replace('$', '')) || Infinity;
                        return priceA - priceB;
                    });
                return matchedProducts.slice(0, 3);
            }

            // Scoring-based search
            const scoredProducts = products.map(product => {
                let score = 0;
                const nameLower = (product.name || "").toLowerCase();
                const descLower = (product.description || "").toLowerCase();

                // Validate category and skin type
                if (!validateProductCategory(product, context.productType || 'serum', context.skinType)) {
                    return { product, score: 0 };
                }

                // Exact and fuzzy matches
                const nameScore = simpleFuzzyMatch(queryLower, nameLower);
                const descScore = simpleFuzzyMatch(queryLower, descLower);
                score += (nameScore * 10) + (descScore * 5);

                // Keyword matches
                keywords.forEach(term => {
                    if (nameLower.includes(term)) score += 3;
                    if (descLower.includes(term)) score += 1;
                });

                // Anti-aging and dry skin boost
                const antiAgingKeywords = ['anti-aging', 'retinol', 'vitamin c', 'hyaluronic acid', 'wrinkles', 'fine lines'];
                const drySkinKeywords = ['hydrating', 'moisturizing', 'dry skin', 'gentle'];
                antiAgingKeywords.forEach(kw => {
                    if (nameLower.includes(kw) || descLower.includes(kw)) score += 5;
                });
                drySkinKeywords.forEach(kw => {
                    if (nameLower.includes(kw) || descLower.includes(kw)) score += 5;
                });

                // Context boost
                if (context.productType && product.categories.includes(context.productType)) {
                    score += 2;
                }

                return { product, score };
            });

            // Sort and filter
            matchedProducts = scoredProducts
                .filter(item => item.score > 0)
                .sort((a, b) => b.score - a.score)
                .map(item => item.product);

            // Deduplicate
            const seen = new Set();
            matchedProducts = matchedProducts.filter(p => {
                const key = p.id || p.name;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });

            return matchedProducts.slice(0, 3);
        }

        async function processResponse(response, userQuery) {
            hideTypingIndicator();

            if (!response || typeof response !== 'object') {
                console.error("Invalid response:", response);
                addMessage("Sorry, I received an unexpected response. Please try again.", 'bot');
                return;
            }

            const queryLower = userQuery.toLowerCase();
            let productsToShow = [];
            const queryType = response.query_type || 'other';
            const skinType = queryLower.includes('dry skin') ? 'dry' : null;

            // Check for specific product query
            const { productName, productUrl } = extractProductInfo(query);
            let specificProduct = null;
            if (productName || productUrl) {
                specificProduct = findProductByNameOrUrl(productName, productUrl);
                if (specificProduct && validateProductCategory(specificProduct, 'serum', skinType)) {
                    const productDescription = `The ${specificProduct.name} is ideal for anti-aging and dry skin, offering hydration and rejuvenation. Check the product page for more details.`;
                    addMessage(productDescription, 'bot');
                    productsToShow.push({
                        ...specificProduct,
                        name: specificProduct.name || "Unnamed Product",
                        description: specificProduct.description || "Description not available.",
                        price: specificProduct.price || "",
                        image: specificProduct.image,
                        url: specificProduct.url && specificProduct.url.includes('planetbeauty.com') ? specificProduct.url : formatProductUrl(specificProduct.name)
                    });
                } else {
                    addMessage(`I couldn't find "${productName || productUrl}" in Planet Beauty's serum catalog. Here are some anti-aging serums for dry skin:`, 'bot');
                }
            }

            // Handle niche queries
            let nicheConfig = null;
            for (const [nicheQuery, config] of Object.entries(nicheQueries)) {
                if (queryLower.includes(nicheQuery) && !specificProduct) {
                    nicheConfig = config;
                    break;
                }
            }

            if (!specificProduct && response.text) {
                addMessage(DOMPurify.sanitize(response.text, { USE_PROFILES: { html: true } }), 'bot');
                updateUserProfile(response.text);
            }

            // Process API-suggested products
            if (!specificProduct && response.products && Array.isArray(response.products) && response.products.length > 0 && queryType === 'product') {
                console.log("Gemini suggested products:", response.products.map(p => p.name));
                for (const suggestedProduct of response.products) {
                    if (!suggestedProduct || typeof suggestedProduct.name !== 'string' || !suggestedProduct.name.trim()) {
                        console.warn("Skipping invalid product:", suggestedProduct);
                        continue;
                    }

                    const nameLower = suggestedProduct.name.trim().toLowerCase();
                    let foundProduct = products.find(p => p.name && p.name.toLowerCase() === nameLower);

                    if (!foundProduct) {
                        const scores = products.map(p => ({
                            product: p,
                            score: simpleFuzzyMatch(nameLower, (p.name || "").toLowerCase())
                        }));
                        const bestMatch = scores.reduce((best, curr) => curr.score > best.score ? curr : best, { score: 0 });
                        if (bestMatch.score > 0.6) {
                            foundProduct = bestMatch.product;
                        }
                    }

                    if (foundProduct && validateProductCategory(foundProduct, 'serum', skinType)) {
                        if (!productsToShow.some(p => (p.id || p.name) === (foundProduct.id || foundProduct.name))) {
                            console.log(`Matched "${suggestedProduct.name}" to: ${foundProduct.name}`);
                            productsToShow.push({
                                ...foundProduct,
                                name: foundProduct.name || "Unnamed Product",
                                description: foundProduct.description || "Description not available.",
                                price: foundProduct.price || "",
                                image: foundProduct.image,
                                url: foundProduct.url && foundProduct.url.includes('planetbeauty.com') ? foundProduct.url : formatProductUrl(foundProduct.name)
                            });
                        }
                    } else {
                        console.log(`No valid serum match for "${suggestedProduct.name}" in catalog.`);
                    }
                }
            }

            // Handle niche or no-match cases
            if (!specificProduct && productsToShow.length === 0 && queryType === 'product') {
                const fallbackProducts = fallbackSearch(userQuery);
                if (nicheConfig) {
                    if (fallbackProducts.length > 0) {
                        addMessage(nicheConfig.message, 'bot');
                        productsToShow = fallbackProducts.map(p => ({
                            ...p,
                            name: p.name || "Unnamed Product",
                            description: p.description || "Description not available.",
                            price: p.price || "",
                            image: p.image,
                            url: p.url && p.url.includes('planetbeauty.com') ? p.url : formatProductUrl(p.name)
                        }));
                    } else {
                        addMessage(`${nicheConfig.message.replace('Here are some', 'I couldn’t find')} Can I help with another beauty product?`, 'bot');
                    }
                } else if (fallbackProducts.length > 0) {
                    addMessage("Based on your query, here are some anti-aging serums suitable for dry skin from Planet Beauty:", 'bot');
                    productsToShow = fallbackProducts.map(p => ({
                        ...p,
                        name: p.name || "Unnamed Product",
                        description: p.description || "Description not available.",
                        price: p.price || "",
                        image: p.image,
                        url: p.url && p.url.includes('planetbeauty.com') ? p.url : formatProductUrl(p.name)
                    }));
                } else {
                    addMessage("I couldn't find matching anti-aging serums for dry skin in Planet Beauty's catalog. Try rephrasing or ask about another beauty product!", 'bot');
                }
            }

            // Apply refinements (e.g., cheapest)
            if (productsToShow.length > 0 && lastQueryContext.preferences.includes('cheapest')) {
                productsToShow = productsToShow
                    .filter(p => p.price && typeof p.price === 'string' && p.price.includes('$'))
                    .sort((a, b) => {
                        const priceA = parseFloat(a.price.replace('$', '')) || Infinity;
                        const priceB = parseFloat(b.price.replace('$', '')) || Infinity;
                        return priceA - priceB;
                    })
                    .slice(0, 3);
                if (productsToShow.length > 0) {
                    addMessage("Here are the most affordable anti-aging serums for dry skin:", 'bot');
                }
            }

            if (productsToShow.length > 0) {
                const maxCards = 3;
                await Promise.all(productsToShow.slice(0, maxCards).map(p => addProductCard(p, userQuery)));
            }
        }

        // --- UI Functions ---
        function addMessage(text, sender) {
            const div = document.createElement('div');
            div.className = sender === 'user' ? 'user-message' : 'bot-message';
            div.innerHTML = DOMPurify.sanitize(text, { USE_PROFILES: { html: true } });
            chatArea.appendChild(div);

            anime({
                targets: div,
                translateY: sender === 'user' ? [10, 0] : [10, 0],
                opacity: [0, 1],
                duration: 400,
                easing: 'easeOutQuad'
            });

            scrollToBottom();
        }

        function showTypingIndicator() {
            hideTypingIndicator();
            const div = document.createElement('div');
            div.id = 'typing-indicator';
            div.className = 'bot-message';
            div.innerHTML = '<span>Thinking</span><span class="typing-dots">.</span>';
            chatArea.appendChild(div);
            scrollToBottom();

            let dotCount = 1;
            const intervalId = setInterval(() => {
                const dotsSpan = div.querySelector('.typing-dots');
                if (dotsSpan) {
                    dotCount = (dotCount % 3) + 1;
                    dotsSpan.textContent = '.'.repeat(dotCount);
                } else {
                    clearInterval(intervalId);
                }
            }, 400);
            div.dataset.intervalId = intervalId.toString();
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                const intervalId = indicator.dataset.intervalId;
                if (intervalId) {
                    clearInterval(parseInt(intervalId, 10));
                }
                indicator.remove();
            }
        }

        function displayError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.innerHTML = DOMPurify.sanitize(`
                <i class="fas fa-exclamation-circle mr-2"></i> ${message}
                <button class="retry-btn mt-2 text-pink-600 underline" aria-label="Retry last message">Try Again</button>
            `);

            const retryBtn = errorDiv.querySelector('.retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', () => {
                    const lastUserMessage = conversationHistory.filter(m => m.role === 'user').pop();
                    if (lastUserMessage && lastUserMessage.parts[0].text) {
                        chatInput.value = lastUserMessage.parts[0].text;
                        updateSendButtonState();
                        sendMessage();
                    } else {
                        addMessage("Could not retrieve the last message to retry.", 'bot');
                    }
                    errorDiv.remove();
                });
            }

            chatArea.appendChild(errorDiv);
            scrollToBottom();
        }

        async function addProductCard(p, queryContext) {
            // Validate URL
            const validatedUrl = p.url && p.url.includes('planetbeauty.com') ? p.url : formatProductUrl(p.name);
            if (!validatedUrl.includes('planetbeauty.com')) {
                console.warn(`Invalid URL for product ${p.name}: ${p.url}. Using generated URL.`);
                return;
            }

            const card = document.createElement('a');
            card.href = validatedUrl;
            card.target = '_blank';
            card.rel = 'noopener noreferrer';
            card.className = 'product-card animate-fade-in';
            card.addEventListener('click', () => {
                if (typeof gtag === 'function') {
                    gtag('event', 'product_click', { event_category: 'Chatbot', event_label: p.name || 'Unknown Product' });
                }
            });

            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-loading';
            const spinner = document.createElement('div');
            spinner.className = 'spinner';
            imageContainer.appendChild(spinner);
            card.appendChild(imageContainer);

            const img = document.createElement('img');
            img.alt = p.name || "Product Image";
            img.className = 'product-image';
            img.style.display = 'none';

            const imageSources = [
                imageCache[p.id || p.name] || p.image,
                getBackupImage(p.name || queryContext),
                backupImages.default
            ].filter(url => url && typeof url === 'string' && url.trim() !== '');

            let currentAttempt = 0;

            const tryLoadNextImage = () => {
                if (currentAttempt >= imageSources.length) {
                    console.warn(`Failed to load any image for product: ${p.name || 'Unknown'}`);
                    imageContainer.innerHTML = `
                        <div class="image-placeholder">
                            <span>Image Not Available</span>
                        </div>`;
                    if (!card.contains(imageContainer)) {
                        const infoDiv = card.querySelector('.product-info');
                        if (infoDiv) {
                            card.insertBefore(imageContainer, infoDiv);
                        } else {
                            card.appendChild(imageContainer);
                        }
                    }
                    return;
                }

                const url = imageSources[currentAttempt];
                console.log(`Attempt ${currentAttempt + 1} for ${p.name || 'Unknown'}: Trying URL ${url}`);

                img.onload = null;
                img.onerror = null;

                img.onload = () => {
                    console.log(`Image loaded successfully: ${img.src}`);
                    img.style.display = 'block';
                    if (imageContainer.parentNode) {
                        imageContainer.replaceWith(img);
                    }
                    if (currentAttempt === 0 && p.id) {
                        imageCache[p.id || p.name] = url;
                        localStorage.setItem('imageCache', JSON.stringify(imageCache));
                    }
                };

                img.onerror = () => {
                    console.warn(`Attempt ${currentAttempt + 1} for ${p.name || 'Unknown'}: URL ${url} failed to load.`);
                    currentAttempt++;
                    tryLoadNextImage();
                };

                img.src = url;
            };

            tryLoadNextImage();

            const MAX_TITLE_LENGTH = 50;
            const MAX_DESC_LENGTH = 100;

            const productName = typeof p.name === 'string' ? p.name : "Unnamed Product";
            const productDesc = typeof p.description === 'string' ? p.description : "Click for details.";

            const truncatedName = productName.length > MAX_TITLE_LENGTH
                ? productName.substring(0, MAX_TITLE_LENGTH) + '...'
                : productName;
            const truncatedDesc = productDesc.length > MAX_DESC_LENGTH
                ? productDesc.substring(0, MAX_DESC_LENGTH) + '...'
                : productDesc;

            const infoDiv = document.createElement('div');
            infoDiv.className = 'product-info';
            infoDiv.innerHTML = DOMPurify.sanitize(`
                <div class="product-name" title="${productName}">${truncatedName}</div>
                <div class="product-description">${truncatedDesc}</div>
                <div class="product-price">${p.price ? DOMPurify.sanitize(p.price) : ""}</div>
            `, { USE_PROFILES: { html: true } });

            card.appendChild(infoDiv);
            chatArea.appendChild(card);

            anime({
                targets: card,
                translateY: [20, 0],
                opacity: [0, 1],
                duration: 500,
                easing: 'easeOutQuad'
            });

            scrollToBottom();
        }

        function scrollToBottom() {
            requestAnimationFrame(() => {
                chatArea.scrollTo({ top: chatArea.scrollHeight, behavior: 'smooth' });
            });
        }

        function updateUserProfile(botResponseText) {
            if (typeof botResponseText !== 'string') return;

            const textLower = botResponseText.toLowerCase();
            let updated = false;
            const newProfile = { ...userProfile };

            if (textLower.includes('dry skin') && newProfile.skinType !== 'Dry') {
                newProfile.skinType = 'Dry';
                updated = true;
            } else if (textLower.includes('oily skin') && newProfile.skinType !== 'Oily') {
                newProfile.skinType = 'Oily';
                updated = true;
            } else if (textLower.includes('combination skin') && newProfile.skinType !== 'Combination') {
                newProfile.skinType = 'Combination';
                updated = true;
            } else if (textLower.includes('sensitive skin') && newProfile.skinType !== 'Sensitive') {
                newProfile.skinType = 'Sensitive';
                updated = true;
            }

            if (textLower.includes('acne') && !newProfile.concerns.includes('Acne')) {
                newProfile.concerns.push('Acne');
                updated = true;
            }
            if (textLower.includes('wrinkles') || textLower.includes('fine lines') || textLower.includes('rejuvenation') && !newProfile.concerns.includes('Aging')) {
                newProfile.concerns.push('Aging');
                updated = true;
            }
            if (textLower.includes('dullness') && !newProfile.concerns.includes('Dullness')) {
                newProfile.concerns.push('Dullness');
                updated = true;
            }

            if (updated) {
                Object.assign(userProfile, newProfile);
                console.log(`User profile updated - Skin Type: ${userProfile.skinType || 'N/A'}, Concerns: ${userProfile.concerns.length > 0 ? userProfile.concerns.join(', ') : 'None'}`);
            }
        }

        function updateQueryContext(query) {
            const queryLower = query.toLowerCase();
            lastQueryContext.queryKeywords = queryLower.split(/\s+/).filter(word => word.length > 2);

            // Detect product type
            lastQueryContext.productType = null;
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => queryLower.includes(keyword))) {
                    lastQueryContext.productType = category;
                    break;
                }
            }

            // Detect skin type
            lastQueryContext.skinType = queryLower.includes('dry skin') ? 'dry' : null;

            // Detect preferences
            if (queryLower.includes('cheapest') || queryLower.includes('cheaper') || queryLower.includes('affordable') || queryLower.includes('lowest')) {
                lastQueryContext.preferences = ['cheapest'];
            } else {
                lastQueryContext.preferences = [];
            }

            console.log('Updated query context:', lastQueryContext);
        }
    </script>
</body>
</html>
