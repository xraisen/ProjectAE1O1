<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Planet Beauty AI Chatbot - Find personalized beauty products with our interactive assistant.">
    <link rel="icon" href="https://placehold.co/16x16/E91e63/FFFFFF?text=PB" type="image/png" onerror="this.href='/images/favicon.png';">
    <title>Planet Beauty AI Chatbot</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DLVD913P7M"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-DLVD913P7M');
    </script>
    <style>
        body { font-family: 'Poppins', sans-serif; background-color: #f8f9fa; margin: 0; overflow-x: hidden; }
        #preloader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #f8f9fa; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; transition: opacity 0.5s ease; }
        #preloader .spinner { width: 50px; height: 50px; border: 5px solid #e91e63; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 1rem; }
        #preloader .percentage { font-size: 1.5rem; font-weight: 500; color: #e91e63; }
        .chat-container { max-width: 900px; margin: 0 auto; box-shadow: 0 4px 6px rgba(0,0,0,0.1); border-radius: 12px; background: white; display: flex; flex-direction: column; height: calc(100vh - 140px); max-height: 800px; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 1.5rem; scroll-behavior: smooth; will-change: scroll-position; }
        .user-message { background: #e91e63; color: white; padding: .75rem 1rem; border-radius: 15px 15px 0 15px; max-width: 80%; margin-left: auto; margin-bottom: 1rem; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .bot-message { background: #f0f0f0; color: #333; padding: .75rem 1rem; border-radius: 15px 15px 15px 0; max-width: 80%; margin-right: auto; margin-bottom: 1rem; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .product-card { display: block; border-radius: 10px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.3s, box-shadow 0.3s; margin: 1rem 0; text-decoration: none; color: inherit; background: white; max-width: 80%; margin-right: auto; }
        .product-card:hover { transform: scale(1.03); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        .product-image { width: 100%; height: 200px; object-fit: cover; display: block; }
        .lazyload, .lazyloading { opacity: 0; transition: opacity 0.3s; }
        .lazyloaded { opacity: 1; }
        .image-loading { position: relative; height: 200px; display: flex; align-items: center; justify-content: center; background-color: #f5f5f5; }
        .spinner { width: 40px; height: 40px; border: 4px solid rgba(233, 30, 99, 0.2); border-top-color: #e91e63; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .image-placeholder { height: 200px; display: flex; align-items: center; justify-content: center; background: #eee; color: #666; font-size: 0.9em; text-align: center; }
        .product-info { padding: 1rem; }
        .product-name { font-weight: 600; margin-bottom: .25rem; }
        .product-description { font-size: 0.9rem; color: #555; margin-bottom: .5rem; }
        .product-price { font-weight: 500; color: #e91e63; }
        .examples-container { display: flex; flex-wrap: wrap; gap: .5rem; margin-bottom: 1rem; max-width: 80%; }
        .example-chip { padding: .5rem 1rem; background: #f0f0f0; border: 1px solid #e0e0e0; border-radius: 20px; cursor: pointer; transition: transform 0.2s, background-color 0.3s, box-shadow 0.2s; font-size: 0.9rem; }
        .example-chip:hover { background: #e91e63; color: white; transform: scale(1.05); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .example-chip:focus { outline: 2px solid #e91e63; outline-offset: 2px; }
        .input-area { display: flex; padding: 1rem; border-top: 1px solid #eee; background: #fff; }
        .input-row { display: flex; gap: 10px; width: 100%; }
        input[type=text] { flex: 1; padding: .75rem 1rem; border: 1px solid #ddd; border-radius: 25px; outline: none; transition: border-color 0.3s; }
        input[type=text]:focus { border-color: #e91e63; }
        input[type=text]:disabled { background-color: #f5f5f5; }
        .send-btn { background: #e91e63; color: white; border: none; border-radius: 50%; width: 45px; height: 45px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.3s, transform 0.2s; flex-shrink: 0; }
        .send-btn:hover { background: #d81b60; transform: scale(1.05); }
        .send-btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        .error-message { background: #ffebee; color: #c62828; padding: .75rem 1rem; border-radius: 15px; margin-bottom: 1rem; max-width: 80%; margin-right: auto; border: 1px solid #f4c7c7; }
        .retry-btn { background: none; border: none; color: #e91e63; text-decoration: underline; cursor: pointer; }
        footer { position: sticky; bottom: 0; background: white; padding: 0.5rem 1rem; color: #6c757d; font-size: 0.875rem; display: flex; justify-content: center; align-items: center; z-index: 10; }
        footer a { color: #e91e63; text-decoration: none; margin-left: 0.25rem; }
        footer a:hover { text-decoration: underline; }
        #typing-indicator .typing-dots { display: inline-block; width: 1.5em; text-align: left; vertical-align: bottom; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.5s ease-out; }
        #debug-panel { position: fixed; bottom: 0; right: 0; background: rgba(30, 30, 30, 0.85); color: white; padding: 1rem; max-width: 300px; max-height: 300px; overflow: auto; font-size: 0.8rem; z-index: 1000; border-top-left-radius: 8px; display: none; }
        .debug-entry { padding: 0.5rem 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2); }
        .debug-button { background: #e91e63; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; margin-top: 0.5rem; cursor: pointer; }
        @media (max-width: 640px) {
            body { padding: 0; }
            .chat-container { border-radius: 0; max-width: 100%; height: 100vh; max-height: none; margin: 0; }
            .chat-area { padding: 1rem; }
            .user-message, .bot-message, .product-card, .examples-container, .error-message { max-width: 90%; }
            .input-area { padding: 0.75rem; }
            input[type=text] { padding: 0.6rem 0.9rem; }
            .send-btn { width: 40px; height: 40px; }
            footer { font-size: 0.8rem; padding-bottom: calc(0.5rem + env(safe-area-inset-bottom)); }
            #preloader .percentage { font-size: 1.2rem; }
            #debug-panel { max-width: 80%; }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <div id="preloader">
        <div class="spinner"></div>
        <div class="percentage">0%</div>
    </div>
    <header class="text-center py-6 px-4 flex-shrink-0 bg-gradient-to-r from-pink-600 to-purple-700 text-white shadow-md animate-fade-in">
        <h1 class="text-3xl sm:text-4xl font-bold">Planet Beauty</h1>
        <p class="text-lg sm:text-xl">Your AI Beauty Assistant ✨</p>
    </header>
    <main class="chat-container flex-grow animate-fade-in">
        <div id="chat-area" class="chat-area">
            <div class="bot-message">Hi there! Welcome to Planet Beauty's AI Assistant. ✨ How can I help you find the perfect products today?</div>
            <div id="examples-container" class="examples-container"></div>
        </div>
        <div class="input-area">
            <div class="input-row">
                <input id="chat-input" type="text" placeholder="Ask about beauty products..." autocomplete="off" aria-label="Type your beauty product question">
                <button id="send-btn" class="send-btn" disabled aria-label="Send message"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </main>
    <footer>
        <span>Developed with ❤️ by</span>
        <a href="https://www.linkedin.com/in/joseespinosa" target="_blank" rel="noopener noreferrer">Jose Espinosa</a>
    </footer>
    <div id="debug-panel">
        <h3 class="font-bold mb-2">Debug Information</h3>
        <div id="debug-content"></div>
        <button id="debug-clear" class="debug-button">Clear</button>
        <button id="debug-close" class="debug-button ml-2">Close</button>
    </div>
    <script>
        // --- Configuration ---
        const GEMINI_API_KEY = 'AIzaSyCpI-eNfqWk_ZiK2qHOj_tD2NzeAJ_U398'; // Demo only
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwhKxZsmVhNGPN0e-zDpBtNliPK9JiP1Bxg7poW8dEB-y--hy6HscOrvrLMAxWk5koX/exec';
        const API_TIMEOUT = 25000;
        const IMAGE_TIMEOUT = 15000;
        const PRELOADER_MIN_DURATION = 1000;
        const PRELOADER_MAX_DURATION = 10000; // Force preloader removal after 10s
        const PERCENTAGE_ANIMATION_DURATION = 2000;
        const PLANET_BEAUTY_DOMAIN = 'https://www.planetbeauty.com';
        const DEBUG_MODE = true; // Enabled to diagnose issues
        const MAX_STORAGE_SIZE = 4 * 1024 * 1024; // 4MB limit for localStorage

        // --- Fallback Definitions ---
        const FALLBACK_QUESTIONS = [
            "What acne treatment products available at Planet Beauty would you recommend for sensitive skin?",
            "Can you suggest a hydrating shampoo and conditioner set from Planet Beauty for color-treated hair?",
            "What are some top-rated makeup primers at Planet Beauty for achieving a long-lasting, matte look?",
            "I'm looking for a retinol serum at Planet Beauty. Which one would be best for someone new to retinol?"
        ];

        const fallbackCategories = {
            skincare: ['moisturizer', 'serum', 'retinol', 'cleanser', 'sunscreen'],
            haircare: ['shampoo', 'conditioner', 'hydrating', 'hair mask'],
            makeup: ['foundation', 'concealer', 'lipstick', 'mascara'],
            devices: ['led mask', 'light therapy', 'facial tool']
        };

        const fallbackBrands = ['Olaplex', 'Murad', 'Dr. Dennis Gross', 'Dermalogica', 'Tatcha'];

        const fallbackProducts = [
            { id: 'fallback1', name: 'Generic Moisturizer', description: 'Hydrating cream for all skin types', price: '$30', image: 'https://placehold.co/600x400', url: 'https://www.planetbeauty.com/products/generic-moisturizer', brand: 'Generic', categories: ['skincare'], descriptionTags: ['hydration'] },
            { id: 'fallback2', name: 'Generic Shampoo', description: 'Gentle shampoo for daily use', price: '$20', image: 'https://placehold.co/600x400', url: 'https://www.planetbeauty.com/products/generic-shampoo', brand: 'Generic', categories: ['haircare'], descriptionTags: [] }
        ];

        // --- State ---
        const userProfile = { skinType: null, skinTone: null, concerns: [] };
        let conversationHistory = [];
        const MAX_HISTORY = 10;
        const imageCache = JSON.parse(localStorage.getItem('imageCache')) || {};
        let products = [];
        let productCategories = {};
        let productBrands = {};
        let lastQueryContext = {
            productType: null,
            preferences: [],
            brand: null
        };
        const backupImages = {
            default: 'https://placehold.co/600x400/E91e63/FFFFFF?text=Planet+Beauty',
            local: '/images/placeholder.png' // Local fallback
        };

        // --- DOM Elements ---
        const chatArea = document.getElementById('chat-area');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const preloader = document.getElementById('preloader');
        const examplesContainer = document.getElementById('examples-container');
        const debugPanel = document.getElementById('debug-panel');
        const debugContent = document.getElementById('debug-content');

        // --- Debug Functions ---
        function debugLog(message, data) {
            if (!DEBUG_MODE) return;
            console.log(message, data);
            const entry = document.createElement('div');
            entry.className = 'debug-entry';
            const timestamp = new Date().toLocaleTimeString();
            let content = `<strong>[${timestamp}]</strong> ${message}`;
            if (data !== undefined) {
                if (typeof data === 'object') {
                    try {
                        content += `<pre>${JSON.stringify(data, null, 2)}</pre>`;
                    } catch (e) {
                        content += `<pre>[Object]</pre>`;
                    }
                } else {
                    content += ` ${data}`;
                }
            }
            entry.innerHTML = content;
            debugContent.appendChild(entry);
            debugPanel.scrollTop = debugPanel.scrollHeight;
            if (DEBUG_MODE && debugPanel.style.display === 'none') {
                debugPanel.style.display = 'block';
            }
        }

        document.getElementById('debug-clear').addEventListener('click', () => {
            debugContent.innerHTML = '';
        });

        document.getElementById('debug-close').addEventListener('click', () => {
            debugPanel.style.display = 'none';
        });

        // --- Utility: Check Storage Availability ---
        function canStoreData(data) {
            try {
                const testKey = '__test__';
                localStorage.setItem(testKey, 'test');
                localStorage.removeItem(testKey);
                const jsonString = JSON.stringify(data);
                if (jsonString.length > MAX_STORAGE_SIZE) {
                    debugLog('Data too large for localStorage', { size: jsonString.length });
                    return false;
                }
                return true;
            } catch (e) {
                debugLog('Storage unavailable or quota exceeded', { error: e.message });
                return false;
            }
        }

        // --- Utility: Clear Storage ---
        function clearStorage() {
            try {
                localStorage.removeItem('cachedProducts');
                localStorage.removeItem('imageCache');
                debugLog('Cleared localStorage');
            } catch (e) {
                debugLog('Failed to clear localStorage', { error: e.message });
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            let percentage = 0;
            const percentageElement = preloader.querySelector('.percentage');
            const animatePercentage = () => {
                return new Promise(resolve => {
                    anime({
                        targets: { value: percentage },
                        value: 90,
                        duration: PERCENTAGE_ANIMATION_DURATION,
                        easing: 'easeOutQuad',
                        update: (anim) => {
                            percentage = Math.round(anim.animatables[0].target.value);
                            percentageElement.textContent = `${percentage}%`;
                        },
                        complete: () => resolve()
                    });
                });
            };

            const minDurationPromise = new Promise(resolve => setTimeout(resolve, PRELOADER_MIN_DURATION));
            const maxDurationPromise = new Promise(resolve => setTimeout(resolve, PRELOADER_MAX_DURATION));
            const animationPromise = animatePercentage();
            let initializationSuccess = true;

            try {
                debugLog('Initializing Planet Beauty AI Assistant');
                // Add delay to allow Cloudflare challenge to complete
                await new Promise(resolve => setTimeout(resolve, 1000));
                products = await fetchProducts();
                debugLog('Products loaded', { count: products.length });
                organizeProducts();
            } catch (error) {
                console.error('Initialization error:', error);
                debugLog('Initialization error', error);
                percentageElement.textContent = 'Error';
                percentageElement.style.color = '#c62828';
                addMessage("Sorry, I couldn't load the product catalog. Using limited recommendations.", 'bot');
                initializationSuccess = false;
            } finally {
                try {
                    await generateSuggestedQuestions();
                } catch (error) {
                    debugLog('Failed to generate suggested questions during init', error);
                }
                // Ensure preloader is removed
                await Promise.race([Promise.all([minDurationPromise, animationPromise]), maxDurationPromise]);
                await anime({
                    targets: { value: percentage },
                    value: 100,
                    duration: 300,
                    easing: 'easeOutQuad',
                    update: (anim) => {
                        percentageElement.textContent = `${Math.round(anim.animatables[0].target.value)}%`;
                    }
                }).finished;
                preloader.style.opacity = '0';
                setTimeout(() => {
                    if (preloader && preloader.parentNode) {
                        preloader.remove();
                        debugLog('Preloader removed', { timedOut: !initializationSuccess });
                    }
                }, 500);
            }

            anime({
                targets: 'header',
                translateY: [-20, 0],
                opacity: [0, 1],
                duration: 800,
                easing: 'easeOutQuad'
            });

            chatInput.addEventListener('keyup', handleInputKeyup);
            chatInput.addEventListener('input', handleInputChange);
            sendBtn.addEventListener('click', () => {
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            });
            chatInput.focus();
            updateSendButtonState();
        });

        // --- Fetch Products ---
        async function fetchProducts() {
            try {
                const cachedProducts = localStorage.getItem('cachedProducts');
                if (cachedProducts) {
                    debugLog('Using cached products');
                    return JSON.parse(cachedProducts);
                }

                const res = await axios.get(`${WEB_APP_URL}?action=getProducts`, {
                    timeout: API_TIMEOUT
                });

                if (res.data && Array.isArray(res.data.products)) {
                    const validatedProducts = res.data.products.map((p, index) => {
                        let productUrl = p.url || formatProductUrl(p.name);
                        if (productUrl && typeof productUrl === 'string') {
                            try {
                                const parsedUrl = new URL(productUrl);
                                if (!parsedUrl.hostname.endsWith('planetbeauty.com')) {
                                    productUrl = formatProductUrl(p.name);
                                } else {
                                    productUrl = productUrl.replace(/^http:/, 'https:');
                                }
                            } catch (e) {
                                productUrl = formatProductUrl(p.name);
                            }
                        }

                        return {
                            ...p,
                            id: p.id || `p${index + 1}`,
                            name: p.name || 'Unnamed Product',
                            description: p.description || 'No description available',
                            price: p.price || '',
                            image: p.image || getBackupImage(''),
                            url: productUrl,
                            brand: p.brand || '',
                            categories: [],
                            descriptionTags: []
                        };
                    });

                    if (canStoreData(validatedProducts)) {
                        clearStorage();
                        localStorage.setItem('cachedProducts', JSON.stringify(validatedProducts));
                        debugLog('Products cached', { count: validatedProducts.length, size: JSON.stringify(validatedProducts).length });
                    } else {
                        debugLog('Skipped caching products due to size or quota');
                    }
                    return validatedProducts;
                } else {
                    throw new Error('Invalid data format from Web App');
                }
            } catch (error) {
                console.error('Failed to fetch products:', error);
                debugLog('Fetch products error', error);
                const cachedProducts = localStorage.getItem('cachedProducts');
                if (cachedProducts) {
                    debugLog('Falling back to cached products');
                    return JSON.parse(cachedProducts);
                }
                debugLog('Using fallback products');
                return fallbackProducts;
            }
        }

        // --- Organize Products ---
        function organizeProducts() {
            if (!products || products.length === 0) {
                console.warn('Product list is empty, using fallbacks');
                fallbackBrands.forEach(b => productBrands[b.toLowerCase()] = []);
                Object.assign(productCategories, fallbackCategories);
                products = fallbackProducts;
                return;
            }

            productBrands = {};
            productCategories = {};
            const defaultCategory = 'miscellaneous';

            products.forEach((p, index) => {
                const name = (p.name || '').toLowerCase();
                const desc = (p.description || '').toLowerCase();
                const brand = (p.brand || '').toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
                const categories = new Set();

                // Validate product
                if (!p.id) p.id = `p${index + 1}`;
                if (!p.name) p.name = 'Unnamed Product';
                if (!p.description) p.description = 'No description available';
                p.categories = [];
                p.descriptionTags = [];

                // Assign brand
                if (brand) {
                    if (!productBrands[brand]) productBrands[brand] = [];
                    productBrands[brand].push(p);
                    p.brand = brand;
                }

                // Infer categories
                if (desc.includes('shampoo') || desc.includes('conditioner') || desc.includes('hair mask') || name.includes('shampoo') || name.includes('hair')) {
                    categories.add('haircare');
                }
                if (desc.includes('moisturizer') || desc.includes('serum') || desc.includes('retinol') || desc.includes('cleanser') || desc.includes('cream') || desc.includes('lotion') || desc.includes('anti-aging') || desc.includes('sunscreen')) {
                    categories.add('skincare');
                }
                if (desc.includes('foundation') || desc.includes('concealer') || desc.includes('lipstick') || desc.includes('mascara') || desc.includes('eyeshadow') || name.includes('makeup')) {
                    categories.add('makeup');
                }
                if (desc.includes('led') || desc.includes('mask') || desc.includes('light therapy') || desc.includes('spectralite') || desc.includes('device') || name.includes('device')) {
                    categories.add('devices');
                }

                // Infer tags
                if (desc.includes('hydration') || desc.includes('moisturize') || desc.includes('dry skin')) p.descriptionTags.push('hydration');
                if (desc.includes('anti-aging') || desc.includes('wrinkle') || desc.includes('fine lines')) p.descriptionTags.push('anti_aging');
                if (desc.includes('acne') || desc.includes('blemish') || desc.includes('breakout')) p.descriptionTags.push('acne');
                if (desc.includes('brighten') || desc.includes('radiance') || desc.includes('glow')) p.descriptionTags.push('brightening');
                if (desc.includes('repair') || desc.includes('damaged hair') || desc.includes('strengthen')) p.descriptionTags.push('hair_repair');
                if (desc.includes('volume') || desc.includes('volumizing') || desc.includes('lift')) p.descriptionTags.push('volume');
                if (desc.includes('spectralite') || desc.includes('led') || desc.includes('light therapy')) p.descriptionTags.push('light_therapy');

                // Default category
                if (categories.size === 0) {
                    categories.add(defaultCategory);
                }

                // Assign categories
                categories.forEach(cat => {
                    if (!productCategories[cat]) productCategories[cat] = [];
                    productCategories[cat].push(p);
                    p.categories.push(cat);
                });
            });

            if (!productCategories[defaultCategory]) productCategories[defaultCategory] = [];

            debugLog('Product organization complete', {
                categories: Object.keys(productCategories).map(cat => `${cat}: ${productCategories[cat].length} products`),
                brands: Object.keys(productBrands).map(brand => `${brand}: ${productBrands[brand].length} products`)
            });
        }

        // --- Suggested Questions ---
        async function generateSuggestedQuestions() {
            if (products.length === 0) {
                debugLog('No products, using fallback questions');
                displaySuggestedQuestions(FALLBACK_QUESTIONS);
                return;
            }
            try {
                const questions = await fetchSuggestedQuestions();
                displaySuggestedQuestions(questions);
            } catch (error) {
                console.error('Failed to generate suggested questions:', error);
                debugLog('Suggested questions error', error);
                displaySuggestedQuestions(FALLBACK_QUESTIONS);
            }
        }

        async function fetchSuggestedQuestions() {
            const availableCategories = Object.keys(productCategories).length > 0
                ? Object.keys(productCategories)
                : Object.keys(fallbackCategories);
            const availableBrands = Object.keys(productBrands).length > 0
                ? Object.keys(productBrands)
                : fallbackBrands;

            const focusCategories = availableCategories.slice(0, 3).join(', ') || 'skincare, haircare, makeup';
            const focusBrands = availableBrands.length > 0
                ? `and popular brands like ${availableBrands.slice(0, 3).map(b => b.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')).join(', ')}`
                : '';

            const prompt = {
                contents: [{
                    role: 'user',
                    parts: [{
                        text: `Generate 4 concise, varied, and helpful beauty-related questions for a chatbot exclusive to Planet Beauty (${PLANET_BEAUTY_DOMAIN}).

Questions MUST focus on products likely available in the Planet Beauty catalog (e.g., focus on ${focusCategories} ${focusBrands}). Include keywords like moisturizer, shampoo, LED mask, or anti-aging to ensure relevance.

Address common user needs like recommendations for specific skin types, hair concerns, or makeup looks. Ensure questions explicitly mention Planet Beauty. Return the response ONLY as a valid JSON array of 4 strings.

Example valid JSON output:
["What acne treatment products available at Planet Beauty would you recommend for sensitive skin?", "Can you suggest a hydrating shampoo and conditioner set from Planet Beauty for color-treated hair?", "What are some top-rated makeup primers at Planet Beauty for achieving a long-lasting, matte look?", "I'm looking for a retinol serum at Planet Beauty. Which one would be best for someone new to retinol?"]`
                    }]
                }],
                generationConfig: {
                    temperature: 0.8,
                    topP: 0.95,
                    topK: 40,
                    maxOutputTokens: 256,
                    responseMimeType: 'application/json'
                },
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                ]
            };

            try {
                const res = await axios.post(GEMINI_API_URL, prompt, {
                    headers: { 'Content-Type': 'application/json' },
                    timeout: API_TIMEOUT
                });

                if (res.data?.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const responseText = res.data.candidates[0].content.parts[0].text;
                    try {
                        const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                        const questions = JSON.parse(cleanedText);
                        if (Array.isArray(questions) && questions.length >= 4 && questions.every(q => typeof q === 'string' && q.trim())) {
                            return questions.slice(0, 4);
                        }
                        throw new Error('Invalid questions format');
                    } catch (parseError) {
                        console.error('JSON Parse Error:', parseError, 'Raw text:', responseText);
                        debugLog('Suggested questions JSON parse error', { error: parseError.message });
                        return FALLBACK_QUESTIONS;
                    }
                }
                throw new Error('No valid response from API');
            } catch (error) {
                debugLog('Suggested questions fetch error', { error: error.message });
                return FALLBACK_QUESTIONS;
            }
        }

        function displaySuggestedQuestions(questions) {
            examplesContainer.innerHTML = '';
            if (!Array.isArray(questions)) {
                console.error("Cannot display suggestions: not an array.", questions);
                questions = FALLBACK_QUESTIONS;
            }
            questions.forEach((question, index) => {
                if (typeof question !== 'string' || !question.trim()) {
                    console.warn(`Skipping invalid suggestion at index ${index}:`, question);
                    return;
                }
                const chip = document.createElement('div');
                chip.className = 'example-chip';
                chip.setAttribute('data-q', question);
                chip.setAttribute('role', 'button');
                chip.tabIndex = 0;
                chip.setAttribute('aria-label', `Ask: ${question}`);
                chip.textContent = question;
                chip.addEventListener('click', handleExampleClick);
                chip.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleExampleClick(e);
                    }
                });
                examplesContainer.appendChild(chip);
            });

            anime({
                targets: '.example-chip',
                translateX: [-20, 0],
                opacity: [0, 1],
                delay: anime.stagger(100),
                duration: 600,
                easing: 'easeOutQuad'
            });
        }

        // --- Utilities ---
        function formatProductUrl(productName) {
            const baseUrl = `${PLANET_BEAUTY_DOMAIN}/products/`;
            if (!productName || typeof productName !== 'string') {
                return `${PLANET_BEAUTY_DOMAIN}/search?q=product`;
            }
            const slug = productName.toLowerCase()
                .replace(/[^\w\s-]/g, '')
                .trim()
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-');
            return baseUrl + slug;
        }

        function getBackupImage(query) {
            const queryLower = (query || "").toLowerCase();
            const queryContext = analyzeQuery(queryLower);

            if (queryContext.brand && productBrands[queryContext.brand]) {
                const brandImages = productBrands[queryContext.brand]
                    .map(p => p.image)
                    .filter(img => img && typeof img === 'string');
                if (brandImages.length > 0) {
                    return brandImages[Math.floor(Math.random() * brandImages.length)];
                }
            }

            if (queryContext.categories.length > 0) {
                for (const category of queryContext.categories) {
                    if (productCategories[category]) {
                        const catImages = productCategories[category]
                            .map(p => p.image)
                            .filter(img => img && typeof img === 'string');
                        if (catImages.length > 0) {
                            return catImages[Math.floor(Math.random() * catImages.length)];
                        }
                    }
                }
            }

            return backupImages.default;
        }

        function analyzeQuery(query) {
            const result = {
                brand: null,
                categories: [],
                descriptionTags: []
            };

            const queryLower = query.toLowerCase();
            for (const brand of Object.keys(productBrands)) {
                if (queryLower.includes(brand)) {
                    result.brand = brand;
                    break;
                }
            }

            for (const category of Object.keys(productCategories)) {
                if (queryLower.includes(category) || (category === 'skincare' && queryLower.includes('moisturizer')) ||
                    (category === 'haircare' && queryLower.includes('shampoo')) ||
                    (category === 'makeup' && queryLower.includes('foundation')) ||
                    (category === 'devices' && queryLower.includes('led'))) {
                    result.categories.push(category);
                }
            }

            if (queryLower.includes('hydration') || queryLower.includes('moisturize')) result.descriptionTags.push('hydration');
            if (queryLower.includes('anti-aging') || queryLower.includes('wrinkle')) result.descriptionTags.push('anti_aging');
            if (queryLower.includes('acne') || queryLower.includes('blemish')) result.descriptionTags.push('acne');
            if (queryLower.includes('brighten') || queryLower.includes('radiance')) result.descriptionTags.push('brightening');
            if (queryLower.includes('repair') || queryLower.includes('damaged hair')) result.descriptionTags.push('hair_repair');
            if (queryLower.includes('volume') || queryLower.includes('volumizing')) result.descriptionTags.push('volume');
            if (queryLower.includes('spectralite') || queryLower.includes('led')) result.descriptionTags.push('light_therapy');

            return result;
        }

        // --- Event Handlers ---
        function handleExampleClick(event) {
            const query = event.currentTarget.getAttribute('data-q');
            if (query) {
                chatInput.value = query;
                updateSendButtonState();
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'example_chip_click', { event_category: 'Chatbot', event_label: query });
                }
            }
        }

        function handleInputKeyup(event) {
            if (event.key === 'Enter' && !sendBtn.disabled) {
                sendMessage();
                if (typeof gtag === 'function') {
                    gtag('event', 'send_message_enter', { event_category: 'Chatbot', event_label: chatInput.value });
                }
            }
        }

        function handleInputChange() {
            updateSendButtonState();
        }

        function updateSendButtonState() {
            sendBtn.disabled = chatInput.value.trim() === '';
        }

        // --- Core Functions ---
        async function sendMessage() {
            const rawMessage = chatInput.value.trim();
            if (!rawMessage) return;

            const message = DOMPurify.sanitize(rawMessage, { USE_PROFILES: { html: false } });
            addMessage(message, 'user');

            const userMessageEntry = { role: 'user', parts: [{ text: message }] };
            conversationHistory.push(userMessageEntry);
            if (conversationHistory.length > MAX_HISTORY * 2) {
                conversationHistory = conversationHistory.slice(-MAX_HISTORY * 2);
            }

            updateQueryContext(message);

            chatInput.value = '';
            updateSendButtonState();
            chatInput.disabled = true;
            sendBtn.disabled = true;

            showTypingIndicator();

            try {
                if (products.length === 0) {
                    throw new Error("Product catalog not available.");
                }
                const response = await callGeminiAPI();
                await processResponse(response, message);
            } catch (error) {
                console.error('Error during message processing:', error);
                debugLog('Message processing error', error);
                hideTypingIndicator();
                let errorMessage = "I encountered an issue. Please try again.";
                if (error.message.includes('timed out')) {
                    errorMessage = "The request timed out. Check your connection and try again.";
                } else if (error.message.includes("Product catalog not available")) {
                    errorMessage = "Sorry, I can't search products right now. Try refreshing.";
                } else if (error.message.includes("blocked")) {
                    errorMessage = `Request blocked: ${error.message}. Please rephrase.`;
                }
                displayError(errorMessage);

                if (products.length > 0) {
                    const fallbackProducts = findRelevantProducts(message);
                    if (fallbackProducts.length > 0) {
                        addMessage("I had trouble with the AI search, but here are some products that might match:", 'bot');
                        await Promise.all(fallbackProducts.map(p => addProductCard(p, message)));
                    } else {
                        addMessage("I couldn't find matching products. Could you rephrase?", 'bot');
                    }
                }
            } finally {
                chatInput.disabled = false;
                updateSendButtonState();
                chatInput.focus();
            }
        }

        async function callGeminiAPI(retry = false) {
            try {
                const res = await axios.get(`${WEB_APP_URL}?action=getPrompt`, {
                    params: { conversationHistory: JSON.stringify(conversationHistory) },
                    timeout: API_TIMEOUT
                });
                const prompt = res.data.prompt;

                const payload = {
                    contents: prompt,
                    generationConfig: {
                        temperature: 0.5,
                        topP: 0.95,
                        topK: 40,
                        maxOutputTokens: 1024,
                        responseMimeType: 'application/json'
                    },
                    safetySettings: [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                    ]
                };

                debugLog('Calling Gemini API');
                const apiRes = await axios.post(GEMINI_API_URL, payload, {
                    headers: { 'Content-Type': 'application/json' },
                    timeout: API_TIMEOUT
                });

                if (apiRes.data?.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const responseText = apiRes.data.candidates[0].content.parts[0].text;
                    try {
                        const cleanedText = responseText.replace(/^```json\s*|```$/g, '').trim();
                        const parsedResponse = JSON.parse(cleanedText);
                        if (typeof parsedResponse !== 'object' || parsedResponse === null ||
                            typeof parsedResponse.text !== 'string' ||
                            typeof parsedResponse.query_type !== 'string' ||
                            !Array.isArray(parsedResponse.products)) {
                            console.error('Invalid JSON structure:', parsedResponse);
                            throw new Error('Invalid response structure.');
                        }
                        conversationHistory.push({ role: 'model', parts: [{ text: cleanedText }] });
                        debugLog('API response received', {
                            queryType: parsedResponse.query_type,
                            productCount: parsedResponse.products.length
                        });
                        return parsedResponse;
                    } catch (parseError) {
                        console.error('JSON Parse Error:', parseError, 'Raw text:', responseText);
                        debugLog('Gemini API JSON parse error', { error: parseError.message, text: responseText });
                        return { text: "I couldn't fully understand the response. Let me try to find products.", query_type: 'other', products: [] };
                    }
                } else if (apiRes.data?.promptFeedback?.blockReason) {
                    console.error(`API request blocked: ${apiRes.data.promptFeedback.blockReason}`);
                    throw new Error(`Request blocked: ${apiRes.data.promptFeedback.blockReason}`);
                } else {
                    console.error('Unexpected API response:', apiRes.data);
                    throw new Error('Unexpected response format.');
                }
            } catch (error) {
                if (!retry && (error.code === 'ECONNABORTED' || (error.response && error.response.status === 408))) {
                    console.warn('API call timed out, retrying...');
                    return await callGeminiAPI(true);
                }
                console.error('Error calling API:', error);
                debugLog('Gemini API error', { error: error.message });
                throw error;
            }
        }

        function updateQueryContext(query) {
            const queryLower = query.toLowerCase();
            const analysis = analyzeQuery(queryLower);
            lastQueryContext = {
                productType: analysis.categories[0] || lastQueryContext.productType,
                preferences: userProfile.concerns || [],
                brand: analysis.brand || lastQueryContext.brand
            };
        }

        function addMessage(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = sender === 'user' ? 'user-message animate-fade-in' : 'bot-message animate-fade-in';
            messageDiv.innerHTML = DOMPurify.sanitize(text);
            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        function showTypingIndicator() {
            const typingDiv = document.createElement('div');
            typingDiv.id = 'typing-indicator';
            typingDiv.className = 'bot-message';
            typingDiv.innerHTML = '<span class="typing-dots">...</span>';
            chatArea.appendChild(typingDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        function hideTypingIndicator() {
            const typingDiv = document.getElementById('typing-indicator');
            if (typingDiv) {
                typingDiv.remove();
            }
        }

        function displayError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message animate-fade-in';
            errorDiv.innerHTML = DOMPurify.sanitize(`${message} <button class="retry-btn" onclick="document.getElementById('chat-input').focus()">Retry</button>`);
            chatArea.appendChild(errorDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        async function addProductCard(product, query) {
            const card = document.createElement('a');
            card.href = product.url;
            card.className = 'product-card animate-fade-in';
            card.setAttribute('target', '_blank');
            card.setAttribute('rel', 'noopener noreferrer');

            let imageHtml = `<div class="image-placeholder">Image not available</div>`;
            if (product.image) {
                if (imageCache[product.image]) {
                    imageHtml = `<img src="${imageCache[product.image]}" alt="${product.name}" class="product-image">`;
                } else {
                    imageHtml = `<div class="image-loading"><div class="spinner"></div></div>`;
                    try {
                        const imgRes = await axios.get(product.image, { timeout: IMAGE_TIMEOUT });
                        imageCache[product.image] = product.image;
                        if (canStoreData(imageCache)) {
                            localStorage.setItem('imageCache', JSON.stringify(imageCache));
                        }
                        imageHtml = `<img src="${product.image}" alt="${product.name}" class="product-image lazyload">`;
                    } catch (error) {
                        console.warn(`Failed to load image for ${product.name}:`, error);
                        debugLog('Product image load error', { product: product.name, error: error.message });
                        imageHtml = `<img src="${backupImages.local}" alt="${product.name}" class="product-image lazyload">`;
                    }
                }
            }

            card.innerHTML = `
                ${imageHtml}
                <div class="product-info">
                    <div class="product-name">${DOMPurify.sanitize(product.name)}</div>
                    <div class="product-description">${DOMPurify.sanitize(product.description)}</div>
                    <div class="product-price">${DOMPurify.sanitize(product.price)}</div>
                </div>
            `;
            chatArea.appendChild(card);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        async function processResponse(response, query) {
            hideTypingIndicator();
            const text = DOMPurify.sanitize(response.text);
            addMessage(text, 'bot');

            if (response.products && response.products.length > 0) {
                const matchedProducts = response.products
                    .map(p => findBestProductMatch(p.name, query))
                    .filter(p => p);

                const uniqueProducts = Array.from(new Map(
                    matchedProducts.map(p => [p.id || p.name, p])
                ).values());

                if (uniqueProducts.length > 0) {
                    await Promise.all(uniqueProducts.map(p => addProductCard(p, query)));
                } else {
                    addMessage("I couldn't find exact matches for the suggested products. Let me try searching our catalog:", 'bot');
                    const fallbackProducts = findRelevantProducts(query);
                    if (fallbackProducts.length > 0) {
                        await Promise.all(fallbackProducts.map(p => addProductCard(p, query)));
                    } else {
                        addMessage("No matching products found. Could you clarify your request?", 'bot');
                    }
                }
            } else if (response.query_type === 'product') {
                const fallbackProducts = findRelevantProducts(query);
                if (fallbackProducts.length > 0) {
                    addMessage("Here are some products that might match your request:", 'bot');
                    await Promise.all(fallbackProducts.map(p => addProductCard(p, query)));
                } else {
                    addMessage("I couldn't find any products matching your request. Could you provide more details?", 'bot');
                }
            }

            if (response.query_type === 'greeting' || response.query_type === 'other') {
                await generateSuggestedQuestions();
            }
        }

        function findBestProductMatch(productName, query) {
            if (!productName || !products.length) return null;
            const queryLower = (query || "").toLowerCase();
            const nameLower = productName.toLowerCase();

            let bestMatch = null;
            let highestScore = -1;

            products.forEach(product => {
                const productNameLower = (product.name || "").toLowerCase();
                const descLower = (product.description || "").toLowerCase();
                let score = 0;

                if (productNameLower === nameLower) {
                    score += 50;
                } else if (productNameLower.includes(nameLower)) {
                    score += 30;
                }

                const queryAnalysis = analyzeQuery(queryLower);
                if (queryAnalysis.brand && product.brand === queryAnalysis.brand) {
                    score += 20;
                }
                if (queryAnalysis.descriptionTags.length > 0) {
                    const descMatchCount = queryAnalysis.descriptionTags.filter(tag =>
                        product.descriptionTags.includes(tag)
                    ).length;
                    score += descMatchCount * 10;
                }
                if (queryAnalysis.categories.length > 0) {
                    const catMatchCount = queryAnalysis.categories.filter(cat =>
                        product.categories.includes(cat)
                    ).length;
                    score += catMatchCount * 5;
                }

                if (descLower.includes(nameLower)) score += 5;

                if (score > highestScore) {
                    highestScore = score;
                    bestMatch = product;
                }
            });

            return bestMatch;
        }

        function findRelevantProducts(query, context = lastQueryContext, maxResults = 3) {
            const queryLower = (query || "").toLowerCase();
            if (!queryLower || products.length === 0) return [];

            debugLog('Starting product search', { query: queryLower, context });

            const queryAnalysis = analyzeQuery(queryLower);
            debugLog('Query analysis', queryAnalysis);

            const refinements = {
                price_low: ['cheapest', 'cheaper', 'affordable', 'lowest price', 'budget', 'inexpensive'],
                price_high: ['luxury', 'high-end', 'premium', 'expensive', 'best'],
                rating: ['top-rated', 'highest rated', 'best rated', 'most popular'],
                new: ['newest', 'latest', 'new', 'just released']
            };

            let activeRefinements = [];
            for (const [refinementType, keywords] of Object.entries(refinements)) {
                if (keywords.some(kw => queryLower.includes(kw))) {
                    activeRefinements.push(refinementType);
                }
            }

            if (activeRefinements.length > 0 && context.productType) {
                debugLog('Refinement detected', { refinements: activeRefinements, previousType: context.productType });
                let productsToRefine = [];
                if (context.brand && productBrands[context.brand]) {
                    productsToRefine = productBrands[context.brand].filter(p =>
                        p.categories.includes(context.productType)
                    );
                } else if (productCategories[context.productType]) {
                    productsToRefine = [...productCategories[context.productType]];
                }

                if (productsToRefine.length > 0) {
                    if (activeRefinements.includes('price_low')) {
                        productsToRefine.sort((a, b) => {
                            const priceA = parseFloat(a.price?.replace(/[^0-9.]/g, '')) || Infinity;
                            const priceB = parseFloat(b.price?.replace(/[^0-9.]/g, '')) || Infinity;
                            return priceA - priceB;
                        });
                        return productsToRefine.slice(0, maxResults);
                    } else if (activeRefinements.includes('price_high')) {
                        productsToRefine.sort((a, b) => {
                            const priceA = parseFloat(a.price?.replace(/[^0-9.]/g, '')) || 0;
                            const priceB = parseFloat(b.price?.replace(/[^0-9.]/g, '')) || 0;
                            return priceB - priceA;
                        });
                        return productsToRefine.slice(0, maxResults);
                    }
                }
            }

            if (queryAnalysis.brand) {
                debugLog('Brand-specific search', { brand: queryAnalysis.brand });
                let brandProducts = productBrands[queryAnalysis.brand] || [];

                if (queryAnalysis.descriptionTags.length > 0 && brandProducts.length > 0) {
                    debugLog('Description filter within brand', { descriptionTags: queryAnalysis.descriptionTags });
                    const descFiltered = brandProducts.filter(p =>
                        p.descriptionTags.some(tag => queryAnalysis.descriptionTags.includes(tag))
                    );
                    if (descFiltered.length > 0) {
                        return descFiltered.slice(0, maxResults);
                    }
                }

                if (queryAnalysis.categories.length > 0 && brandProducts.length > 0) {
                    debugLog('Category filter within brand', { categories: queryAnalysis.categories });
                    const categoryFiltered = brandProducts.filter(p =>
                        p.categories.some(cat => queryAnalysis.categories.includes(cat))
                    );
                    if (categoryFiltered.length > 0) {
                        return categoryFiltered.slice(0, maxResults);
                    }
                }

                if (brandProducts.length > 0) {
                    debugLog('Returning general brand products');
                    return brandProducts.slice(0, maxResults);
                }
            }

            if (queryLower.includes('led') || queryLower.includes('mask') ||
                queryLower.includes('device') || queryLower.includes('tool') ||
                queryLower.includes('spectralite') || queryLower.includes('light therapy')) {
                debugLog('Specialized device search');
                const deviceProducts = productCategories['devices'] || [];

                if (queryLower.includes('spectralite') ||
                    (queryLower.includes('dennis') && (queryLower.includes('led') || queryLower.includes('mask')))) {
                    const spectraliteProducts = deviceProducts.filter(p =>
                        p.name && (
                            p.name.toLowerCase().includes('spectralite') ||
                            p.descriptionTags.includes('light_therapy') ||
                            (p.brand.includes('dennis') && (p.name.toLowerCase().includes('led') || p.name.toLowerCase().includes('mask')))
                        )
                    );
                    if (spectraliteProducts.length > 0) {
                        return spectraliteProducts.slice(0, maxResults);
                    }
                }

                if (deviceProducts.length > 0) {
                    return deviceProducts.slice(0, maxResults);
                }
            }

            debugLog('Performing keyword scoring search');
            const stopWords = new Set(['the', 'a', 'an', 'is', 'for', 'what', 'can', 'you', 'recommend', 'find', 'me', 'i', 'need', 'with', 'of', 'my', 'skin', 'hair', 'product', 'products', 'at', 'from', 'planet', 'beauty']);
            const keywords = queryLower.split(/[\s,.;!?-]+/)
                .filter(word => word.length > 2 && !stopWords.has(word));

            debugLog('Extracted keywords', keywords);

            const scoredProducts = products.map(product => {
                let score = 0;
                const nameLower = (product.name || "").toLowerCase();
                const descLower = (product.description || "").toLowerCase();

                keywords.forEach(keyword => {
                    if (nameLower.includes(keyword)) score += 10;
                    if (descLower.includes(keyword)) score += 5;
                    if (product.categories.includes(keyword)) score += 15;
                    if (product.descriptionTags.includes(keyword)) score += 10;
                });

                return { product, score };
            }).filter(item => item.score > 0);

            scoredProducts.sort((a, b) => b.score - a.score);
            return scoredProducts.slice(0, maxResults).map(item => item.product);
        }
    </script>
</body>
</html>
